#summary Here are reported all the informations needed to manage the repository

<wiki:toc max_depth="3" />

==Introduction==
This document explains the structure of the repository for the tuProlog project. This document will explain also the policies used to update the contents in the repository in case of bug fixes, releases, feature implementations and so on. The document is intended for the people that have to manage the repository, for the developers it is not required to read it.

This document is targeted on SVN (Subeversion) source code version system therefore sometimes in the examples we will show specific commands for this system. Since the system used here is subversion we choose to follow the main repository layout convention (described in the [http://svnbook.red-bean.com/ SVN book]) in order to ensure that other users that are familiar with subversion or with its conventions can easily navigate and use our repository, however we add some specific strategies that are not exactly described in the SVN book. Some of the concepts are also taken from some articles of [http://ariejan.net/ Ariejan de Vroom].

This document we will give as known some basic concepts about version control systems and subversion, like: repository, working copy, revision, branch, tag, merge, commit, update, switch, check out, copy-modify-merge model. For more informations on this concepts we advice to read the [http://svnbook.red-bean.com/ SVN book], in the Appendix A a brief description of a typical work cycle is given. 

==Structure of the repository==
As mentioned in the introduction, following the SVN convention, our repository will contain a "trunk" subdirectory for the main development line, a "branches" subdirectory in which specific branches for bug fixing and thesis will be created, and a "tags" subdirectory in which specific tags will be created. The tuProlog project is composed of four parts: the java version of the engine, the eclipse plugin, the android application both based on the java version and the .NET version of the engine automatically produced from the java version using the tool [http://www.ikvm.net/ IKVM.NET]. These four parts are divided into four different projects, all hosted in the same repository in order to simplify the relationships between them as described in the following sections.

{{{
/svn
	/2p
		/trunk
		/branches
		/tags
	/2p-android
		/trunk
		/branches
		/tags
	/2p-plugin
		/trunk
		/branches
		/tags
	/2p-net
		/trunk
		/branches
		/tags
}}}

==Trunk Management==
The trunk contains the most current development code at all times. This is where we work up to our next major release of code. The trunk is designed as a space where the application is always in a consistent state (*successful build and test*), in other words every commit to the trunk should not break the application. In accordance to the previous statement before commit to the trunk the application should be tested in deep in order to ensure that anything is changed, for this reason the development directly against the trunk is allowed only in the cases where the changes are very small and easy to describe and understand. Otherwise if the modification is deep (and maybe require a lot of changes before reaching the final stable result) *it is mandatory* to create another branch (they are intended exactly for this purpose) and develop the modification against it, at the end of the process, when a stable result is reached, the work done in the branch can be merged inside the trunk. Using this approach the development cycle will not break because when someone is working on a bug fix in its specific branch another developer, at the same time, can develop a new feature and at the end, the work of the two can be merged together in order to have a better application with less bugs. 

In summary:
  # The application in the trunk must be in a consistent state (build + tests) in any moment;
  # Every commit to the trunk should bring the application in a consistent state;
  # If the point 2 is impossible you must create a branch.

==Branches management==
As mentioned in the previous section the branches are the tools to not break the development cycle. A branch, in short, is a copy of the trunk in a specific moment. After the creation of the branch it has its own life, so, in other words, each commit into a branch is not committed into the trunk. This way you are free to commit bit by bit changes into the branch without break the stable version of the application in the trunk. This approach will give us also more control over the changes that each developer made, in fact we can analyze each small modification and so we can easily recognize a new bug that can be introduced during the development against a branch. When the work on the branch is finished the changes made in it should be reintegrated inside the trunk in order to ensure that the trunk contains the latest version of the application. 

Before describing how to manage the different kind of branches used in our structure, we will focus on two important topics regarding branching and merging: synchronization and reintegration of a branch. 

===Keeping a Branch in Sync===
As explained before, the usefulness of the branches is that your are “disconnected” from the trunk so you let the other developers work without any problems. This is of course a nice feature but lets consider this scenario: while you are working on your branch the code in the trunk is changed a lot, very deeply, when you have to reintegrate your work into the trunk you will recognize that your new feature is not working anymore in the new version of the application or you have a lot of conflicts to resolve. This is a typical problem that you will encounter if you work on your own branch in total isolation. The best way to handle this is to replicate the changes made in the trunk to your own branch, just to make sure they mesh well with your changes. Subversion is aware of the history of your branch and knows when it is divided away from the trunk. To replicate the latest trunk changes to your branch, first make sure your working copy of the branch is “clean”—that it has no local modifications reported by svn status. Then simply run:

{{{
$ svn merge ^/2p/trunk 
--- Merging r345 through r356 into '.': 
      U Theory.java 
      U Struct.java $
}}}

This basic syntax—`svn <merge> <URL>`—tells Subversion to merge all recent changes from the URL to the current working directory (which is typically the root of your working copy). Also notice that we're using the caret (^) syntax to avoid having to type out the entire /trunk URL.
*After running the prior example, your branch working copy now contains new local modifications, and these edits are duplications of all of the changes that have happened on the trunk since you first created your branch*. After performing the merge, you might also need to resolve some conflicts or possibly make some small edits to get things working properly. If you encounter serious problems, you can always abort the local changes by running "svn revert . -R" which will undo all local modifications. If things look good, however, you can submit these changes into the repository:

{{{
$ svn commit -m 
"Merged latest trunk changes to TH-Montanari.”.
}}}

[https://code.google.com/p/tuprolog/wiki/HOWTOBranchSynchronization Here] it is possible to find a guide that explains how to synchronize a branch using the Subclipse 1.8 plugin for Eclipse. 

Given the past experience with the tuProlog project we think that it is not mandatory to impose a fixed period for branch synchronization (like once a week or something similar). However, there are situations where a branch synchronization is needed to simplify the successive reintegration of the branch. For example when there is overlapping between the work of two or more developers and one of the branches is reintegrated into te trunk: in that case it is necessary to synchronize the other branches. Another example is when there is a long-lived branch: in this case in fact it is possible that many other branches have been reintegrated in the trunk and if the long-lived branch is not synchronized often, its successive merge with the trunk could be difficult because they are too far apart. It is responsibility of who manages the repository to detect these situations and request a branch synchronization to the developers that are working on active branches.
 
===Reintegrating a Branch===
This is the operation that has to be done when the work on a branch is finished and it is necessary to make the changes available to the others developers, merging the branch with the trunk. The process is simple. First, bring the branch in sync with the trunk again, just as you've been doing all along. Now, you use svn merge with the --reintegrate option to replicate your branch changes back into the trunk. *You will need a working copy of the trunk to do that*. Your trunk working copy cannot have any local edits or be at mixed-revisions. While these are typically best practices for merging, they are required when using the --reintegrate option.
Once you have a clean working copy of the trunk, you are ready to merge the branch back into it:

{{{
$ svn update # (make sure the working copy is up to date)
$ svn merge --reintegrate ^/2p/branches/TH-Montanari
--- Merging differences between repository URLs into '.': 
       U Theory.java 
       U Struct.java 
       U ant.xml.
$ # build, test, verify, ...
$ svn commit -m "Merge TH-Montanari back into trunk!" 
         Sending	Theory.java 
	 ...
	Committed revision 391.
}}}

The branch has now been remerged back into the main line of development. By specifying the --reintegrate option, you are asking Subversion to carefully replicate only those changes unique to your branch. (And in fact, it does this by comparing the latest trunk tree with the latest branch tree: the resulting difference is exactly the branch changes).
Now that the branch is merged into the trunk, you may wish to remove it from the repository:

{{{
$ svn delete ^/2p/branches/TH-Montanari -m "Remove TH-Montanari, reintegrated with trunk in r391."
Committed revision 392.
}}}

*This operation is not totally destructive, indeed even though the branch is no longer visible in the /branches directory, its existence is still an immutable part of the repository's history*. A simple svn log command on the /branches URL will show the entire history of the branch. The branch can even be resurrected at some point (see the section called “Resurrecting Deleted Items” in the SVN book).

*In summary, to reintegrate a branch:*
  # make the last synchronization with the trunk;
  # get a working copy of the trunk and update it;
  # merge the branch with the working copy;
  # commit the changes;
  # delete the branch.

[https://code.google.com/p/tuprolog/wiki/HOWTOBranchReintegration Here] it is possible to find a guide that explains how to reintegrate a branch using the Subclispe 1.8 plugin for Eclipse.

The following sections describe the three categories of branches used during the work on tuProlog: bug fix, experimental and thesis. These conventions have been developed in order to understand immediately from the name of the branch which is its purpose.

===Bug Fix Branches===
When a bug is recognized, if that bug is easy to solve and can be solved with just *one commit*, it is possible to fix it directly from where it was discovered (trunk or branch) but if the bug is more complex and requires more time and work to be fixed, the better way is to create a new branch and develop the solution on that branch. For this kind of branches we chose the following template for the name of the relative directory "BUG-[bug ID]", where bug ID  is the Identification Number of the bug in the bug tracker or a name that recalls the bug itself. An example:

{{{
/2p
	/trunk
	/branches
		/BUG-3456
	/tags
}}}

The bug branch can be used like any other branch and when the work is finished it has to be reintegrated into the trunk or into the branch as described in the previous sections

We recall here the best procedure to handle a bug:
  # after the discovery insert a detailed description in the bug traker;
  # create one or more tests that expose the bug;
  # create a bug branch to fix it;
  # reintegrate the branch when the work is finished.

===Experimental Branches===
The experimental branches are intended to be used when there is the necessity to try a new technology or when a student works on a specific project related to tuProlog (called "Attività Progettuale" in italian). Since this could be a dangerous operation and we do not want to compromise the work in the trunk, a new branch is the right solution. In this case the template is the following: "TRY-[keywords of the exepriment]", where with some keywords you have to describe what is going to change, for example:

{{{
/2p
	/trunk
	/branches
		/BUG-3456
		/TRY-JDK1.7
		/TRY-generics
	/tags
}}}

An experimental branch can be abandoned (or deleted) or reintegrated into the trunk

===Thesis Branches===
Since most of the work on the tuProlog engine is made by students as thesis work, a kind of branch for this particular case is provided. Usually a thesis on tuProlog is like trying a new technology or a new approach to solve a problem or to improve the quality of the engine so this kind of branch is like an experimental branch but a new template for the name is used in order to let the professors to find the right directory immediately. The template is: "TH-[surname of the student]". An example:

{{{
/2p
	/trunk
	/branches
		/BUG-3456
		/TRY-JDK1.7
		/TRY-generics
		/TH-Montanari
	/tags
}}}

To enable the student as a committer on the tuProlog repository, the student must have a google account and he has to be added in the [https://code.google.com/p/tuprolog/people/list People section] giving him the "Committer" role. The "Duties" filed should contain a short description of the thesis and the URL of the branch associated to the student, in order to let the people involved in the project to better understand in which direction the work is going on.

When the work is finished the branch will be reintegrated into the trunk if it is good enough otherwise the branch can be deleted or maintained if future work will take place. 

==Tags Management==
Exactly as a branch, a tag is a copy of the trunk (or of a branch) in a specific moment, the only difference is that we decided (SVN convention) to never commit to a tag. This way it will remain a snapshot of our project in a certain moment forever. This seems to be redundant since in a version control repository each change is tracked (revisions), this is true, but the reason why we use tags instead of revisions to track releases is that it's not so easy to remember that release 1.0 of a piece of software is a particular subdirectory of revision 4822, coping the state of the software in a certain directory makes it a trivial task. So the gold rule for the tags is: *never commit to one of them*.

===Release Tags===
These kind of tags mark the release (and state) of our code at that release point. The template for the name of the relative directory is: "REL-[`version number`]", where the version number is defined by the rules described [https://code.google.com/p/tuprolog/wiki/ProjectsVersionManagement Here]. Here is reported an example:

{{{
/2p
	/trunk
	/branches
	/tags
		/REL-2.3.0
}}}

(CARTELLA release POPOLATA CON GLI ZIP QUANDO SI TAGGA)


==Relationships between projects==
tuProlog is a characteristic project consisting of four sub-projects: the Java SE version, the Android version, the Eclipse plugin and the .NET version. The Java version is the actual implementation of the Prolog engine (in addition to the user interface for Java SE), while the Android version and the Eclipse plugin are simply the implementations of the user interfaces for the respective platforms. The Android version and the Eclipse plugin use the core of the engine, written in java, as a library and build around it the user interface: an Android app and a plugin respectively. For the .NET version the situation is slightly different. In fact the .NET version is obtained automatically converting the java bytecode into .NET bytecode using the tool [http://www.ikvm.net/ IKVM.NET]: the result of the conversion is a working executable file. The only code implemented specifically for the .NET platform is the OOLibrary that is the counterpart of the JavaLibrary on the Java platform (please refer to the manual for more informations on these libraries). 

In more detail, the Android version and the Eclipse plugin have as dependency the file tuprolog.jar, produced by the Java version. This file contains only the core of the tuProlog engine (the Java SE UI is contained in the file 2p.jar). The files 2p.jar and tuprolog.jar are used as input to the IKVM.NET tool to produce the files 2p.exe and tuprolog.dll. After the conversion with IKVM.NET the files 2p.exe and tuprolog.dll are already the .NET version, the only code that is added (in C#) is the implementation of the OOLibrary. The image below should clarify the situation. 

<img src="http://tuprolog.googlecode.com/svn/wiki/images/NotesOnTheManagementOfTheRepository/tuPrologVersions.png" height="50%" width="50%"/>

===Enforce Dependencies using svn:externals===
As described in the previous section, three projects out of four depends on two files, 2p.jar and tuprolog.jar. This dependency as to be reflected on the repository as well in order to ensure that the developers have everything they need to start working immediately after the checkout, without the need to download additional software using other checkout commands and set-up references. Subversion offers a mechanism called *Externals Definitions* that can be used to achieve this. An externals definition is a link to a resource on the repository (or on another repository) that can be attached to any versioned directory using the `svn:externals` property. When the folder that contains the property is checked out, Subversion will read the property and checkout also the resources referenced by it. This way, to build a working copy that consists of many resources in different locations on the repository, it is not necessary to do several checkout manually but, once the externals definitions are in place, everything happens automatically upon a single checkout operation.

During the design of the repository structure we had in mind two goals: simplicity and immediacy. We did not want to incur in the problems mentioned above because the majority of developers are students, so we tried to design the repository in a way that the projects, after the checkout, could be used immediately, limiting the operations from the developers as much as possible. Therefore *we decided to put the required files (2p.jar and tuprolog.jar) directly on the repository and use externals definitions to link them to the projects that require them*. This way, when a developer checks out the Android project for example, the file tuprolog.jar will be automatically downloaded and copied in the "libs" folder, so the developer is immediately ready to start his work. This is slightly against the "SVN best practices" that discourage to put binaries on the repository because it should be used only for code. In these situations the SVN book advices to setup externals definitions so as to download the code necessary to compile the other project. This means, for example, that if a developer has to work on the Android version an externals definition is needed to download the entire Java version, otherwise the Android app will not compile. This complicates the use of the project because the developer has to deal with may files that are not directly related to his project and it is necessary that also the code downloaded (the Java version in the example above) compiles, so this requires to download also its dependencies and setup the IDE to correctly compile it (classpath, etc.).

After the decision to put the binaries on the repository there was another question to answer, where can we put those files? The fundamental idea is that the projects that depend from the tuProlog core are released immediately after the release of a new tuProlog version. In fact in that moment the new tuprolog.jar file is available and the other projects can be built in order to incorporate the new core. Therefore there is a "virtual link" between each project and a specific version of the core, something like: the current version of the Android app is "linked" to tuProlog version 2.8 because it uses its core (this is also reflected in the scheme that we adopted for the [http://code.google.com/p/tuprolog/wiki/ProjectsVersionManagement version numbering]). In order to keep this link as visible as possible, to eventually simplify the analysis of older versions of the project, we decided to put the binary files (2p.jar and tuprolog.jar) in the tags folder. Moreover, the tags folder is by definition "untouchable" so it represents a good place where to put binary files that must not be modified. *When a version of the core is tagged with x.y.z as version number, the two files are generated and copied in the folder /2p/tags/REL-x.y.z/build/archives/* (look at the following sections for more information on the automatization of this process using Ant). At this point, in the projects that requires tuprolog.jar (Android and Eclipse) is used an externals definition on the root folder of the project in the trunk in oder to checkout the required file in the "lib" folder of the project ("libs" folder for Android). 

Example: 
  * in the folder /2p/tags/REL-2.8.0/build/archives/ there are the files, 2p.jar and tuprolog.jar;
  * in the root folder of the Android project in the trunk (/2p-android/trunk) is used the following "svn:externals" property
{{{
^/2p/tags/REL-2.8.0/build/archives/tuprolog.jar libs/tuprolog.jar
}}}
This property says that the file `^`/2p/tags/REL-2.8.0/build/archives/tuprolog.jar (note the use of the `^` character in replacement of the entire URL of the repository) has to be copied in the folder "libs" upon checkout. This way, when the developer checks out the Android project, subversion will also automatically download tuprolog.jar inside "libs". Moreover, this use of the property makes immediately recognizable to which version of the core the current Android app is linked.

In a similar way externals definitions are used to copy the tuProlog manual into the working copy ("doc" folder), ensuring in this way that the developer obtain everything he needs with a single checkout.

To summarize:
  * the files required by the projects are placed in binary format in the repository;
  * the binaries are placed in the tags folder;
  * using "svn:externals" the binaries are copied automatically where required.

====.NET Special Considerations====
For the . NET version of tuProlog is slightly different than the Android and Eclipse version. In fact, in .NET the file tuprolog.jar is not used as a library, as in Android and Eclipse, but it is used to generate the actual .NET version simply converting the java bytecode to .NET bytecode using IKVM.NET. This means that there is nothing on the .NET side that uses tuprolog.jar, instead the OOLibrary and the examples on the .NET side uses tuprolog.dll and 2p.exe. At this point the question was, if it would be better to link the files tuprolog.jar and 2p.jar inside the .NET projects and in this case the developer would have to produce tuprolog.dll and 2p.exe by himself, or produce automatically those files when a new tuProlog version for Java is tagged and link those files inside the .NET projects, in this way the developer, upon a single checkout, obtains everything he needs to work. We chose the second alternative because it was the best choice to keep the complexity low. In fact, probably some developers will work only on the OOLibrary or on future libraries and they do not need any knowledge about how the .NET version is created and about IKVM.NET, therefore generating the exe and dll files in advance permits to let the the developers focus on what they have to do, without bothering about the generation of these files.

In more details, when a new tag for the Java version is created, using the Ant script discussed below, IKVM.NET is used to generate some .NET files, in particular:
  * 2p.exe, tuprolog.dll and javassist.dll generated from 2p.jar, tuprolog.jar and javassist.jar respectively. They are placed in the folder `^`/2p/tags/REL-x.y.z/build/archives/net/.
  * fit.dll and junit.exe generated from fit.jar and junit.jar. They are placed in `^`/2p/tags/REL-x.y.z/build/archives/net/lib/.
  * 2pWithUnitTests.dll and fixtures.dll. They are required to run the Java tests on the .NET platform (refer to Montanari's thesis) and are placed in `^`/2p/tags/REL-x.y.z/build/archives/net/test/.

For example, the tag of the Java version 2.8.0 looks like this:
{{{
/2p
  /tags
      /REL-2.8.0
          /build
              /archives
                  /2p.jar
                  /tuprolog.jar
                  /net
                      /2p.exe
                      /tuprolog.dll
                      /javassist.dll
                      /lib
                          /fit.dll
                          /junit.exe
                      /test
                          /2pWithUnitTests.dll
                          /fixtures.dll  
}}}

At this point, similarly to what is already done for Android and Eclipse, those files are linked to the "lib" folder on the .NET trunk (`^`/2p-net/trunk/lib) using externals definitions, so the projects on the .NET side (OOLibrary and examples) can reference them and the developer does not need to generate them manually.

This solution is a bit "dirty" because in the tags for the Java version are placed .NET files, but in this way we are more uniform with the management of the dependencies for the other projects (Android and Eclipse) and simplify the work of the .NET developers.

In addition to dependencies analyzed before, the .NET projects depend also on the IKVM.NET libraries. In this case we adopted a similar approach: the IKVM.NET libraries are copied in the "ikvm" folder (`^`/2p-net/ikvm) keeping the version number:
{{{
/2p-net
  /ikvm
    /ikvm-7.0.4335.0
    /ikvm-7.1.4532.2
    /ikvm-7.2.4630.5
}}}

Using externals definitions the required libraries are linked in the "lib" folder in the trunk (`^`/2p-net/trunk/lib) and referenced by the .NET projects. In this way we void coping the IKVM.NET libraries directly into the projects saving in this way space on the repository because the required libraries are a discrete number. Moreover, looking at the `snv:externals` property, it is always possible to understand which version of IKVM.NET is being used.

===Impact on the Repository Management===
(tags)

(new version of ikvm)


==Management Automation using Ant==

===Java===

===Android===

===Eclipse===

===.NET===

Per java il tutto è abbastanza semplice:
  # aggiorna tutto quello che deve aggiornare, compresa la versione in VersionInfo e committa;
  # fa girare il task "11.release.bin" per produrre lo zip da caricare nella sezione Downloads;
  # per taggare, siccome dobbiamo generare i file exe e dll per .NET, deve impostare in ant/environment.properties la directory di installazione di IKVM, "ikvm.dir" e il nome utente su google code di chi esegue il tag, "username". A questo punto facendo girare il task "12.tag" le verrà chiesta la password per google code che trova qui (https://code.google.com/hosting/settings) e lui taggerà il codice che c'è nel trunk generando anche tutti i file che ci servono per gli altri progetti (exe, dll e jar). In questo passo non è necessario committare quando ha modificato environment.properties, quindi la sua mail non comparirà sul repo. Il nome della cartella generata nei tags sarà "REL-2.7.1".

Per android ed il plugin il tutto è un po' meno automatico:
  # modificare gli externals: se guarda le proprietà di svn sul trunk di android e sul progetto "alice.tuprologx.eclipse" vedrà gli externals nella forma "^/2p/tags/REL-2.7.0/build/archives/tuprolog.jar lib/tuprolog.jar". L'unica cosa da fare è cambiare lo 0 in 1. A questo punto si committa e si fa UPDATE per assicurarsi che il nuovo tuprolog.jar sia scaricato.
  # modifica del numero di versione come descritto qui https://code.google.com/p/tuprolog/wiki/ProjectsVersionManagement e commit;
    # per android una volta modificata la versione e committato, lui ha già rigenerato il nuovo apk;
    # per il plugin bisogna seguire la guida di Lorena.

Per .NET siamo ancora un po' indietro:
  # modificare gli externals: anche qui se guarda le proprietà dei progetti "OOLibrary" e "NETFileRunner" sotto il trunk vedrà gli externals che puntano  ai tags di java, anche in questo caso basta modificare il numero di versione. Commit e UPDATE.
  # build della OOLib: da visual studio si fa "Build All" per rigenerare le dll della libreria e delle convenzioni.
  # composizione della release: qui c'è il buco. In pratica bisogna copiare i file di ikvm e le varie dll di tuprolog seguendo la struttura che vede nei tags di .NET (cartella build) per poi generare lo zip da caricare sul repo, farlo a mano è ovviamente una palla :) però ancora non c'è lo script che lo fa in automatico. In realtà non ci dovrebbe molto per farlo perché la struttura è già definita, è solo da fare delle gran copie di file via ant, appena ho un'attimo lo faccio.






= Compilation Target for Android =
At the moment (Nov-2012) the Android SDK is not capable to use java libraries compiled with target level 1.7, this will lead to a `JavaClassNotFoundException`. For this reason the default target level for the java project is set to 1.6 (file ant/environment.properties).
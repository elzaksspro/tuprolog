%=======================================================================
\chapter{Multi-paradigm programming in Prolog and Java}
\label{ch:mpp-in-java}
%=======================================================================

\tuprolog{} supports multi-paradigm (and multi-language) programming between Prolog and Java in a complete, four-dimensional way:

\begin{itemize}
  \item using Java from Prolog: \textit{JavaLibrary}
  \item using Prolog from Java: \textit{the Java API}
  \item augmenting Prolog from Java: \textit{developing new libraries}
  \item augmenting Java from Prolog: \textit{the P@J framework}
\end{itemize}

%-----------------------------------------------------------------------
\section{Using Java from Prolog: \textit{JavaLibrary}}
\label{sec:java-library}
%-----------------------------------------------------------------------
The first MPP dimension offered by \tuprolog{} is the ability to fully access Java resources (objects, classes, methods, etc) in a full-fledged yet straightforward way, completely avoiding the intricacies (object and method pre-declarations in some awkward syntax, pre-compilations, etc) that are often found in other Prolog systems.
%
The unique \tuprolog{} approach keeps the two computational models clearly separate, so that neither the Prolog nor the Java semantics is affected by the coexistence of the logical and imperative/object-oriented paradigms in the same program.
%
In this way, any Java package, library, etc. is immediately available to the Prolog world with no effort, according to the motto {``one library for all libraries''}. So, for instance, Swing classes can be easily exploited to build the graphical support of a Prolog program, and the same holds for JDBC to access databases, for the socket package to provide network access, for RMI to access remote Java objects, and so on.

The two basic bricks of JavaLibrary are:
\begin{itemize}
  \item the mapping between Java types and suitable Prolog types;
  \item the set of predicates to perform operations on Java objects.
\end{itemize}

%-----------------------------------
\subsection{Type mapping}
%-----------------------------------

The general mapping between Prolog types and Java types is summarized in Table \ref{tab:prolog-java-type-mapping}.

\begin{table}[h]
  \centering
  \begin{tabular}{|p{1.8cm}|p{4.7cm}|p{4.7cm}|}
  \hline
  \textit{Categories} & \textit{From Prolog to Java} & \textit{From Java to Prolog}\\
  \hline
  integers   & Prolog integers are mapped onto Java \texttt{int} or \texttt{long} types, as appropriate & all Java integer types are mapped onto Prolog (integer) numbers\\
  \hline
  reals      & Prolog reals are mapped onto Java \texttt{double} & all Java floating-point types are mapped onto Prolog (real) numbers\\
  \hline
  booleans   & N/A & Boolean Java values are mapped onto ad-hoc constants (\texttt{true} and \texttt{false})\\
  \hline
  strings    & Prolog atoms are mapped onto Java \texttt{String}s & Java \texttt{char}s and \texttt{String}s are mapped onto Prolog atoms\\
  \hline
  wildcards  & Prolog indifference (the \textit{any} variable (\_)) is mapped onto the Java \texttt{null} costant & The Java \texttt{null} value is mapped onto the Prolog \textit{any} variable (\_)\\
  \hline
  \end{tabular}
  \caption{Prolog/Java type mapping.}\label{tab:prolog-java-type-mapping}
\end{table}

\noindent Two aspects are worth highlighting:
\begin{itemize}
  \item although the Prolog language considers a comprehensive \texttt{number} type for both integer and real values, the two kinds are considered separately in this table, both for the user's convenience and because \tuprolog{} internally does use different types for this purpose (indeed, the \tuprolog{} internal representation of numbers does distinguish \texttt{Number} into \texttt{Int}, \texttt{Long}, \texttt{Double} and \texttt{Float}, based on the value to be stored---details in Section \ref{ssec:java-api-types}).
      More precisely, in the Prolog-to-Java direction, only the Java \texttt{int}, \texttt{long} and \texttt{double} types are used as target types for the mapping, while in the opposite Java-to-Prolog direction any of the numeric Java types are accepted (including \texttt{short}, \texttt{byte} and \texttt{float}) for mapping onto Prolog numbers.
  \item since the Prolog language does not include a specific boolean type, the table reports N/A in the Prolog-to-Java direction; however, the \texttt{true} and \texttt{false} atoms can be provided to Java methods when appropriate, as Java boolean methods return/accept these atoms when boolean values are involved.
\end{itemize}

%---------------------------------------------------------------
\subsection{Creating and accessing objects: an overview}
\label{ssec:creating-and-accessing-objects}
%---------------------------------------------------------------

JavaLibrary provides many predicates to access, manipulate and interact with Java objects and classes in a complete way.
In this section, the fundamental predicates are presented that enable the Prolog user to create and access Java objects---that is, calling methods and getting return values.
A detailed description of all the available features is reported in Section \ref{ssec:all-javalibrary-predicates}.

For the sake of concreteness, Table \ref{tab:javalibrary-counter-example} reports a simple Java class (a counter) and the Prolog program that exploits it via JavaLibrary.

\begin{description}
  \item [Object creation]
        Java objects are created via the predicate
        
        \texttt{~~~~~java\_object(%
                 \textit{ClassName}, \textit{ArgumentList}, \textit{ObjectRef})}
        
        where \texttt{\textit{ClassName}} is a Prolog atom bound to the name of the
        Java class (e.g. \verb|'Counter'|, \verb|'java.io.FileInputStream'|, etc.), \texttt{\textit{ArgumentList}} is a Prolog list supplying the required arguments to the class constructor (the empty list matches the default constructor), and \texttt{\textit{ObjectRef}} holds the reference to the newly-created object.
        In the case of arrays, \texttt{\textit{ClassName}} ends with \texttt{[]}.
        
        The reference to the newly-created object is bound to \texttt{\textit{ObjectRef}},
        which is typically a ground Prolog term; alternatively, an unbound term
        may be used, in which case the term is bound to an automatically-generated
        Prolog atom of the form \verb|'$obj_N'|, where \texttt{N} is an integer.

        In both cases, these atoms are interpreted as object references --
        and therefore used to operate on the Java object from Prolog -- \textit{only} in the context of \texttt{JavaLibrary}'s predicates: this is how \tuprolog{} guarantees that the two computational models are never mixed, and therefore that each semantics is preserved.

        The predicate fails if \texttt{\textit{ClassName}} does not identify a valid Java class, or the constructor does not exists, or arguments in
        \texttt{\textit{ArgumentList}} are not ground, or \textit{ObjectRef}
        already identifies another object in the system.

        The lifetime of the binding between the Java object and the Prolog term
        is the duration of the demonstration: by default, the binding is maintained in case of backtracking, but this behavior can be changed by setting the flag \texttt{java\_object\_backtrackable} flag to \texttt{true}.
        
        \color{red}
        There is no way to make such a binding permanent from the Prolog side\footnote{\color{red} There is, however, a way to do so from the Java side, coherently with the side-effect nature of imperative languages: see the \texttt{register} primitive in Section \ref{sec:java-api}}---that is, there is no way to ``keep alive'' a Java object beyond the current query, for retrieving it in a subsequent demonstration, because this would contradict the Prolog approach of avoiding anything like ``global variables''. So, the only way to maintain a Java object available to another predicate (within the same demonstration) is to pass it over as an argument.
        \textbf{Perch\'{e} non prevedere un predicato in JavaLibrary ??}
        \normalcolor

  \item [method calling]
        methods can be invoked on Java objects via the \texttt{<-/2} predicate,
        according to a send-message pattern. The predicate comes in two flavors, with/without return argument:

        \texttt{~~~~~\textit{ObjectRef} <- \textit{MethodName}(\textit{Arguments})}

        \texttt{~~~~~\textit{ObjectRef} <- \textit{MethodName}(\textit{Arguments})
                returns \textit{Term}}

        where \texttt{\textit{ObjectRef}} is an atom interpreted as a Java object
        reference as above, and \texttt{\textit{MethodName}} is the Java name of the method to be invoked, along with its \texttt{\textit{Arguments}}.
        
        The \texttt{returns} keyword is used to retrieve the value returned from non-void Java methods and bind it to a Prolog term: if the type of the returned value can be mapped onto a primitive Prolog data type (a number or a string), \texttt{\textit{Term}} is unified with the corresponding Prolog value; otherwise, \texttt{\textit{Term}} is handled as an object reference, that is, as a Prolog ground term\footnote{If it is not ground, it is automatically bound to a term like \texttt{\$obj\_N}.} bound to the Java object returned by the method.

        Static methods can also be invoked, adopting \texttt{class(\textit{ClassName})} as the target \texttt{\textit{ObjectRef}}.
        
        The call fails if \texttt{\textit{MethodName}} does not identify a valid method for the object (for the class, in the case of static methods), or arguments in \texttt{\textit{ArgumentList}} are invalid because of a wrong signature or because they are not ground.

  \item [property selection]
        public object properties can be accessed via the \texttt{.} infix operator, in conjunction with the \texttt{set} / \texttt{get} pseudo-method pair:
        
        \texttt{~~~~~\textit{ObjectRef}.\textit{Field} <- set(\textit{GroundTerm})}
        
        \texttt{~~~~~\textit{ObjectRef}.\textit{Field} <- get(\textit{Term})}
        
        The first construct sets the public field \texttt{\textit{Field}} to the specified \texttt{\textit{GroundTerm}}, which may be either a value of a primitive data type, or a reference to an existing object: if it is not ground, the infix predicate fails.
        
        Analogously, the second construct retrieves the value of the public field
        \texttt{\textit{Field}}, handling the returned \texttt{\textit{Term}} as above.

        Again, class properties can be accessed using the  \texttt{class(\textit{ClassName})} form for  \texttt{\textit{ObjectRef}}.

        It is worth to point out that such \texttt{set} / \texttt{get} 
        pseudo-methods are \textit{not} methods of some class, but just
        part of of the property selection operator.

  \item [array access]
        Due to the special Java syntax for arrays, ad hoc helper predicates are required to access Java array elements:
        
        \texttt{~~~~~java\_array\_set(\textit{ArrayRef}, \textit{Index}, \textit{Object})}
        
        \texttt{~~~~~java\_array\_set\_\textit{\emph{Basic Type}}(\textit{ArrayRef}, \textit{Index}, \textit{Value})}
        
        \texttt{~~~~~java\_array\_get(\textit{ArrayRef}, \textit{Index}, \textit{Object})}
        
        \texttt{~~~~~java\_array\_get\_\textit{\emph{Basic Type}}(\textit{ArrayRef}, \textit{Index}, \textit{Value})}
        
        \texttt{~~~~~java\_array\_length(\textit{ArrayObject}, \textit{Size})}

  \item [type cast]
        the \texttt{as} infix operator is used to explicitly cast method arguments to a given type, typically for exploiting overloading resolution:

        \texttt{~~~~~\textit{ObjectRef} as \textit{Type}}

        By writing so, the object represented by \texttt{\textit{ObjectRef}} is
        considered to belong to type \texttt{\textit{Type}}: the latter can be either a class name, as above, or a primitive Java type such as \texttt{int}.
        
  \item [class loading and dynamic compilation]
        The \texttt{java\_class/4} creates, compiles and loads a new Java class from a source text:
        
        \texttt{~~~~~java\_class(\textit{SourceText}, \textit{FullClassName},}\\
        \texttt{\mbox{~~~~~~~~~~~~~~~~}\textit{ClassPathList}, \textit{ObjectRef})}

        where \texttt{\textit{SourceText}} is a string representing the text source of the new Java class, \texttt{\textit{FullClassName}} is the full class name, and \texttt{\textit{ClassPathList}} is a (possibly empty) Prolog list of class paths that may be required for a successful dynamic compilation of this class.
        %
        In this case, \texttt{\textit{ObjectRef}} is a reference to an instance of the meta-class \texttt{java.lang.Class} representing the newly-created class.
        
        The predicate fails if \texttt{\textit{SourceText}} leads to compilation errors, or the class cannot be located in the package hierarchy, or \texttt{\textit{ObjectRef}} already identifies another object in the system.
\end{description}

\noindent Exceptions thrown by Java methods or constructors can be managed by means of \tuprolog{}'s special \texttt{java\_catch} and \texttt{java\_throw} predicates, discussed in Section \ref{ssec:java-exceptions-in-tuprolog}.

%------------------------
\subsubsection{Examples}
%------------------------

\begin{table}
\textit{Java class:}
\begin{verbatim}
public class Counter {
    public String name;
    private long value = 0;

    public Counter() {}
    public Counter(String aName) { name = aName; }

    public void setValue(long val) { value=val; }
    public long getValue() { return value; }
    public void inc() { value++; }

    static public String getVersion() { return "1.0"; }
}
\end{verbatim}

\textit{Prolog program:}
\begin{verbatim}
    ?-  java_object('Counter', ['MyCounter'], myCounter),

        myCounter <- setValue(5),
        myCounter <- inc,
        myCounter <- getValue returns Value,
        write(X), nl,

        class('Counter') <- getVersion return Version,
        write(Version), nl,

        myCounter.name <- get(Name),
        class('java.lang.System') . out <- get(Out),
        Out <- println(Name),

        myCounter.name <- set('MyCounter2'),

        java_object('Counter[]', [10], ArrayCounters),
        java_array_set(ArrayCounters, 0, myCounter).
\end{verbatim}
\caption{The Java \texttt{Counter} class and the Prolog program that exploits it via JavaLibrary.}
\label{tab:javalibrary-counter-example}
\end{table}

To taste the flavor of \texttt{JavaLibrary}, let us consider the example shown in Table \ref{tab:javalibrary-counter-example}, which reports both a simple Java class (a counter) and the Prolog program that exploits it via JavaLibrary.

First, a \texttt{Counter} instance is created (line 1) providing the \texttt{MyCounter} name as the constructor argument: the reference to the new object is bound to the Prolog atom \texttt{myCounter}.

Then, this reference is used to invoke several methods (lines 2--4) via the \verb|<-/2| and the (\verb|<-|,\texttt{returns})\texttt{/3} operators---namely, \texttt{setValue(5)} (which is void and therefore returns nothing), \texttt{inc} (which takes no arguments and is void, too) and \texttt{getValue} (which takes no argument but returns an int value);
the returned value (hopefully, 5) is bound to the \texttt{X} Prolog variable, which is finally printed via the Prolog \texttt{write/1} predicate (line 5).
%
Of course, the predicate succeeds also if \texttt{X} is already bound to 5, while fails if it is already bound to anything else.

Then, the class (static) method \texttt{getVersion} is called (line 6) and the retrieved version number is printed (line 7).
 
Now the (public) instance \textit{\texttt{Name}} property is read, and its value printed via the Java \texttt{System.out.println} method: to this end, a reference to the \texttt{java.lang.System} class is first obtained (line 8), then its \texttt{out} (static) field is accessed and its value retrieved and bound to the \texttt{Out} Prolog variable (line 9), which is used as the target for the invocation of the \texttt{println} method (line 10).

Finally, the \texttt{name} property of the \texttt{myCounter} object is changed to the new \texttt{'MyCounter2'} value (line 11).

The last part of the example deals with an array of 10 \texttt{Counter}s: the array is first created (line 12), and the \texttt{myCounter} object is assigned to its first (0th) element (line 13).

The key point is that the only requirement here is the presence of the \texttt{Counter.class} file in the proper location in the file system, according to Java naming conventions: no other auxiliary information is needed---no headers, no pre-declarations, pre-compilations, etc.

%------------------

Table \ref{tab:jexamples-swing} shows one further example, where the Java Swing API is
exploited to graphically choose a file from Prolog: a Swing \texttt{JFileChooser} dialog is instantiated and bound to the Prolog variable \texttt{Dialog} (a univocal Prolog atom of the form \verb|'$obj_N'|, to be used as the object reference, is automatically generated and bound to that variable) and is then used to invoke the \texttt{showOpenDialog} and
\texttt{getSelectedFile} methods: the Prolog anonymous variable \texttt{\_} is used to represent the Java \texttt{null} value in \texttt{showOpenDialog}.
%
The \texttt{File} object returned by the file chooser is finally queries for the corresponding \texttt{FileName}, which is returned to the outer predicate caller.

%Further examples about exploiting standard Java libraries from \tuprolog{} can be found in \cite{tuprolog-padl2001} and \cite{tuprolog-scico2005}.

\begin{table}
\begin{verbatim}
test_open_file_dialog(FileName) :-
    java_object('javax.swing.JFileChooser', [], Dialog),
    Dialog <- showOpenDialog(_),
    Dialog <- getSelectedFile returns File,
    File <- getName returns FileName.
\end{verbatim}
\caption{Creating and using a Swing component from a \tuprolog{} program.}
\label{tab:jexamples-swing}
\end{table}

%-----------------------------------------------------------------------
\subsubsection{Registering object bindings}
\label{sssec:register}
%-----------------------------------------------------------------------

Besides the Prolog predicates, \texttt{JavaLibrary} embeds the \texttt{register} function, which, unlike the previous functionalities, is to be used on the Java side.
%
Its purpose is to permanently associate an existing Java object \texttt{\textit{obj}} to a Prolog identifier \texttt{\textit{ObjectRef}}, according to the syntax:\\

\texttt{boolean register(Struct \textit{ObjectRef}, Object \textit{obj})\\
    \mbox{~~~~~~~~~~~}throws InvalidObjectIdException;}\\

\noindent where \texttt{\textit{ObjectRef}} is a ground term (otherwise an \texttt{InvalidObjectIdException} exception is raised) representing the Java object
\texttt{\textit{obj}} in the context of \texttt{JavaLibrary}'s predicates.
The function returns \texttt{false} if that object is already registered under a different \texttt{\textit{ObjectRef}}.

As an example of use, let us consider the following case:\footnote{An
  explicit cast to \texttt{alice.tuprolog.lib.JavaLibrary} is needed because
  \texttt{loadLibrary} returns a reference to a generic
  \texttt{Library}, while the \texttt{register} primitive is defined in
  \texttt{JavaLibrary} only.}
%
{\small
\begin{verbatim}
Prolog core = new Prolog();
Library lib = core.loadLibrary("alice.tuprolog.lib.JavaLibrary");
((alice.tuprolog.lib.JavaLibrary)lib).register(new Struct("stdout"),
                                               System.out);
\end{verbatim}}
%
\noindent Here, the Java object \texttt{System.out} is registered
for use in \tuprolog{} under the name \texttt{stdout}.
%
So, within the scope of the \texttt{core} engine, a Prolog program
can now contain
\begin{verbatim}
stdout <- println('What a nice message!')
\end{verbatim}
as if \texttt{stdout} was a pre-defined \tuprolog{} identifier.

%---------------------------------------------------------------------
\subsection{Predicates}
\label{ssec:all-javalibrary-predicates}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\subsubsection{Method Invocation, Object and Class Creation}
%---------------------------------------------------------------------

\begin{itemize}
%
\item \bti{java\_object/3}\\
\noindent\bt{java\_object(ClassName, ArgList, ObjId)} is true iff
\bt{ClassName} is the full class name of a Java class available on
the local file system, \bt{ArgList} is a list of arguments that
can be meaningfully used to instantiate an object of the class,
and \bt{ObjId} can be used to reference such an object;
%
as a side effect, the Java object is created and the reference to
it is unified with \bt{ObjId}.
%
It is worth noting that \bt{ObjId} can be a Prolog variable (that
will be bound to a ground term) as well as a ground term (not a
number).\\
\template{java\_object(+full\_class\_name, +list, ?obj\_id)}
%
\item \bti{java\_object\_bt/3}\\
\noindent\bt{java\_object\_bt(ClassName, ArgList, ObjId)} has the same behaviour of \bt{java\_object/3}, but the binding that is established between the \bt{ObjId} term and the Java object is destroyed with backtracking.\\
\template{java\_object\_bt(+full\_class\_name, +list, ?obj\_id)}
%
\item \bti{destroy\_object/1}\\
\noindent\bt{destroy\_object(ObjId)} is true and as a side effect
the binding between \bt{ObjId} and a Java object,
possibly established, by previous predicates is destroyed.\\
\template{destroy\_object(@obj\_id)}
%
\item \bti{java\_class/4}\\
\noindent\bt{java\_class(ClassSourceText, FullClassName, ClassPathList, ObjId)}
is true iff \bt{ClassSouceText} is a source string describing a
valid Java class declaration, a class whose full name is
\bt{FullClassName}, according to the classes found in paths
listed in \bt{ClassPathList}, and \bt{ObjId} can be used as a
meaningful reference for a \texttt{java.lang.Class} object
representing that class;
%
as a side effect the described class is (possibly created and)
loaded and made available to the system.\\
\template{java\_class(@java\_source, @full\_class\_name, @list, ?obj\_id)}
%
\item \bti{java\_call/3}\\
\noindent\bt{java\_call(ObjId, MethodInfo, ObjIdResult)} is true iff
\bt{ObjId} is a ground term currently referencing a Java object,
which provides a method whose name is the functor name of the term
\bt{MethodInfo} and possible arguments the arguments of
\bt{MethodInfo} as a compound, and \bt{ObjIdResult} can be used as
a meaningful reference for the Java object that the method
possibly returns.
%
As a side effect the method is called on the Java object
referenced by the \bt{ObjId} and the object possibly returned by
the method invocation is referenced by the \bt{ObjIdResult} term.
%
The anonymous variable used as argument in the \bt{MethodInfo}
structure is interpreted as the Java \texttt{null} value.\\
\template{java\_call(@obj\_id, @method\_signature, ?obj\_id)}
%
\item \verb|'<-'/2|\\
\noindent\verb|'<-'(ObjId, MethodInfo)| is true iff \bt{ObjId} is
a ground term currently referencing a Java object, which provides a
method whose name is the functor name of the term \bt{MethodInfo}
and possible arguments the arguments of \bt{MethodInfo} as a
compound.
%
As a side effect the method is called on the Java object
referenced by the \bt{ObjId}.
%
The anonymous variable used as argument in the \bt{MethodInfo}
structure is interpreted as the Java \texttt{null} value.\\
\template{'<-'(@obj\_id, @method\_signature)}
%
\item \bti{return/2}\\
\noindent\verb|return('<-'(ObjId, MethodInfo), ObjIdResult)| is true
iff \bt{ObjId} is a ground term currently referencing a Java object,
which provides a method whose name is the functor name of the term
\bt{MethodInfo} and possible arguments the arguments of
\bt{MethodInfo} as a compound, and \bt{ObjIdResult} can be used as
a meaningful reference for the Java object that the method
possibly returns.
%
As a side effect the method is called on the Java object
referenced by the \bt{ObjId} and the object possibly returned by
the method invocation is referenced by the \bt{ObjIdResult} term.
%
The anonymous variable used as argument in the \bt{MethodInfo}
structure is interpreted as the Java \texttt{null} value.\\
%
It is worth noting that this predicate is equivalent to the
\texttt{java\_call} predicate.\\
\template{return('<-'(@obj\_id, @method\_signature), ?obj\_id)}
%
\end{itemize}

%---------------------------------------------------------------------
\subsubsection{Java Array Management}
%---------------------------------------------------------------------
\begin{itemize}
%
\item \bti{java\_array\_set/3}\\
\noindent\bt{java\_array\_set(ObjArrayId, Index, ObjId)} is true iff
\bt{ObjArrayId} is a ground term currently referencing a Java
array object, \bt{Index} is a valid index for the array and
\bt{ObjId} is a ground term currently referencing a Java object
that could inserted as an element of the array (according to Java
type rules).
%
As side effect, the object referenced by \bt{ObjId} is set in the
array referenced by \bt{ObjArrayId} in the position (starting from
0, following the Java convention) specified by \bt{Index}.
%
The anonymous variable used as \bt{ObjId} is interpreted as the
Java \texttt{null} value.
%
This predicate can be used for arrays of Java objects:
%
for arrays whose elements are Java primitive types (such as
\texttt{int}, \texttt{float}, etc.) the following predicates can
be used, with the same semantics of \bt{java\_array\_set} but
specifying directly the term to be set as a \tuprolog{} term
(according to the mapping described previously):\\
%
\mbox{~~~~}\bt{java\_array\_set\_int(ObjArrayId, Index, Integer)}\\
\mbox{~~~~}\bt{java\_array\_set\_short(ObjArrayId, Index, ShortInteger)}\\
\mbox{~~~~}\bt{java\_array\_set\_long(ObjArrayId, Index, LongInteger)}\\
\mbox{~~~~}\bt{java\_array\_set\_float(ObjArrayId, Index, Float)}\\
\mbox{~~~~}\bt{java\_array\_set\_double(ObjArrayId, Index, Double)}\\
\mbox{~~~~}\bt{java\_array\_set\_char(ObjArrayId, Index, Char)}\\
\mbox{~~~~}\bt{java\_array\_set\_byte(ObjArrayId, Index, Byte)}\\
\mbox{~~~~}\bt{java\_array\_set\_boolean(ObjArrayId, Index, Boolean)}\\
%
\template{java\_array\_set(@obj\_id, @positive\_integer, +obj\_id)}
%
%
%
\item \bti{java\_array\_get/3}\\
\noindent\bt{java\_array\_get(ObjArrayId, Index, ObjIdResult)} is
true iff \bt{ObjArrayId} is a ground term currently referencing a
Java array object, \bt{Index} is a valid index for the array, and
\bt{ObjIdResult} can be used as a meaningful reference for a Java
object contained in the array.
%
As a side effect, \bt{ObjIdResult} is unified with the reference to
the Java object of the array referenced by \bt{ObjArrayId} in the
\bt{Index} position.
%
This predicate can be used for arrays of Java objects:
%
for arrays whose elements are Java primitive types (such as
\texttt{int}, \texttt{float}, etc.) the following predicates can
be used, with the same semantics of \bt{java\_array\_get} but
binding directly the array element to a \tuprolog{} term
(according to the mapping described previously):\\
%
\mbox{~~~~}\bt{java\_array\_get\_int(ObjArrayId, Index, Integer)}\\
\mbox{~~~~}\bt{java\_array\_get\_short(ObjArrayId, Index, ShortInteger)}\\
\mbox{~~~~}\bt{java\_array\_get\_long(ObjArrayId, Index, LongInteger)}\\
\mbox{~~~~}\bt{java\_array\_get\_float(ObjArrayId, Index, Float)}\\
\mbox{~~~~}\bt{java\_array\_get\_double(ObjArrayId, Index, Double)}\\
\mbox{~~~~}\bt{java\_array\_get\_char(ObjArrayId, Index, Char)}\\
\mbox{~~~~}\bt{java\_array\_get\_byte(ObjArrayId, Index, Byte)}\\
\mbox{~~~~}\bt{java\_array\_get\_boolean(ObjArrayId, Index, Boolean)}\\
%
\template{java\_array\_get(@obj\_id, @positive\_integer, ?obj\_id)}
%
%
\item \bti{java\_array\_length/2}\\
\noindent\bt{java\_array\_length(ObjArrayId, ArrayLength)} is true
iff \bt{ArrayLength} is the length of the Java array referenced by
the term \bt{ObjArrayId}.\\
\template{java\_array\_length(@term, ?integer)}
%
\end{itemize}

%---------------------------------------------------------------------
\subsubsection{Helper Predicates}
%---------------------------------------------------------------------

\begin{itemize}
%
\item \bti{java\_object\_string/2}\\
\noindent\bt{java\_object\_string(ObjId, String)} is true iff
\bt{ObjId} is a term referencing a Java object and
\bt{PrologString} is the string representation of the object
(according to the semantics of the \texttt{toString} method
provided by the Java object).\\
\template{java\_object\_string(@obj\_id, ?string)}
%
\end{itemize}

%---------------------------------------------------------------------
\subsection{Functors}
%---------------------------------------------------------------------

No functors are provided by the \texttt{JavaLibrary} library.

%---------------------------------------------------------------------
\subsection{Operators}
%---------------------------------------------------------------------

\begin{table}[h]
    %
    \begin{center}{\small\tt
    \begin{tabular}{p{2cm}|p{1cm}|p{1cm}}\hline\hline
    Name & Assoc. & Prio. \\ \hline\hline
    <-   & xfx & 800\\
    returns     & xfx & 850 \\
    as   & xfx & 200\\
    .   & xfx & 600\\
    \hline\hline
    \end{tabular}
    }\end{center}
\end{table}

%\clearpage


%-----------------------------------------------------------------------
\subsection{Examples}
%-----------------------------------------------------------------------

The following examples are designed to show \texttt{JavaLibrary}'s
ease of use and flexibility.

%-------------------------------
\subsubsection{RMI Connection to a Remote Object}
%-------------------------------

Here we connect via RMI to a remote Java object.
%
In order to allow the reader to try this example with no need of
other objects, we connect to the remote Java object identified by
the name \verb|'prolog'|, which is an RMI server bundled with
the \tuprolog{} package, and can be spawned by typing:

{\small%
\texttt{java -Djava.security.all=policy.all  alice.tuprologx.runtime.rmi.Daemon}
}

\noindent Then, we invoke the object method whose signature is

{\small%
\texttt{SolveInfo solve(String goal);}
}
%
{\small%
\begin{verbatim}
    ?-  java_object('java.rmi.RMISecurityManager', [], Manager),
        class('java.lang.System') <- setSecurityManager(Manager),
        class('java.rmi.Naming') <- lookup('prolog') returns Engine,
        Engine <- solve('append([1],[2],X).') returns SolInfo,
        SolInfo <- success returns Ok,
        SolInfo <- getSubstitution returns Sub,
        Sub <- toString returns SubStr, write(SubStr), nl,
        SolInfo <- getSolution returns Sol,
        Sol <- toString returns SolStr, write(SolStr), nl.
\end{verbatim}
}
%
\noindent The Java version of the same code would be:
%
{\small%
\begin{verbatim}
        System.setSecurityManager(new RMISecurityManager());
        PrologRMI core = (PrologRMI) Naming.lookup("prolog");
        SolveInfo info = core.solve("append([1],[2],X).");
        boolean ok = info.success();
        String sub = info.getSubstiturion();
        System.out.println(sub);
        String sol = info.getSolution();
        System.out.println(sol);
\end{verbatim}
}


%-------------------------------
\subsubsection{Java Swing GUI from \tuprolog}
%-------------------------------

What about creating Java GUI components from the \tuprolog{}
environment?
%
Here is a little example, where a standard Java Swing open file
dialog windows is popped up:
%
{\small%
\begin{verbatim}
    open_file_dialog(FileName):-
        java_object('javax.swing.JFileChooser', [], Dialog ),
        Dialog <- showOpenDialog(_) returns Result,
        write(Result),
        Dialog <- getSelectedFile returns File,
        File <- getName returns FileName,
        class('java.lang.System') . out <- get(Out),
        Out <- println('you want to open file '),
        Out <- println(FileName).
\end{verbatim}
}

%-------------------------------
\subsubsection{Database access via JDBC from \tuprolog}
%-------------------------------

This example shows how to access a database via the Java standard
JDBC interface from \tuprolog{}.
%
The program computes the minimum path between two cities, fetching
the required data from the database called `distances'.
%
The entry point of the Prolog program is the \texttt{find\_path}
predicate.
%
{\small%
\begin{verbatim}
    find_path(From, To) :-
        init_dbase('jdbc:odbc:distances', Connection, '', ''),
        exec_query(Connection,
          'SELECT city_from, city_to, distance FROM distances.txt',
          ResultSet),
        assert_result(ResultSet),
        findall(pa(Length,L), paths(From,To,L,Length), PathList),
        current_prolog_flag(max_integer, Max),
        min_path(PathList, pa(Max,_), pa(MinLength,MinList)),
        outputResult(From, To, MinList, MinLength).

    paths(A, B, List, Length) :-
        path(A, B, List, Length, []).

    path(A, A, [], 0, _).
    path(A, B, [City|Cities], Length, VisitedCities) :-
        distance(A, City, Length1),
        not(member(City, VisitedCities)),
        path(City, B, Cities, Length2, [City|VisitedCities]),
        Length is Length1 + Length2.

    min_path([], X, X) :- !.
    min_path([pa(Length, List) | L],  pa(MinLen,MinList), Res) :-
        Length < MinLen, !,
        min_path(L, pa(Length,List), Res).
    min_path([_|MorePaths], CurrentMinPath, Res) :-
        min_path(MorePaths, CurrentMinPath, Res).

    writeList([]) :- !.
    writeList([X|L]) :- write(','), write(X), !, writeList(L).

    outputResult(From, To, [], _) :- !,
        write('no path found from '), write(From),
        write(' to '), write(To), nl.
    outputResult(From, To, MinList, MinLength) :-
        write('min path from '), write(From),
        write(' to '), write(To), write(': '),
        write(From), writeList(MinList),
        write('  - length: '), write(MinLength).

    % Access to Database

    init_dbase(DBase, Username, Password, Connection) :-
        class('java.lang.Class') <- forName('sun.jdbc.odbc.JdbcOdbcDriver'),
        class('java.sql.DriverManager') <- getConnection(DBase, Username, Password)
            returns Connection,
        write('[ Database '), write(DBase), write(' connected ]'), nl.

    exec_query(Connection, Query, ResultSet):-
        Connection <- createStatement returns Statement,
        Statement <- executeQuery(Query) returns ResultSet,
        write('[ query '), write(Query), write(' executed ]'), nl.

    assert_result(ResultSet) :-
        ResultSet <- next returns Valid, Valid == true, !,
        ResultSet <- getString('city_from') returns From,
        ResultSet <- getString('city_to') returns To,
        ResultSet <- getInt('distance') returns Dist,
        assert(distance(From, To, Dist)),
        assert_result(ResultSet).
    assert_result(_).
\end{verbatim}
}

%-------------------------------
\subsubsection{Dynamic compilation}
%-------------------------------

As already said, the \texttt{java\_class} predicate performs
\textit{dynamic compilation}, creating an instance of a Java
\texttt{Class} class that represents the public class declared in
the source text provided as argument.
%
The created \texttt{Class} instance, referenced by a Prolog term,
can be used to create instances via the \texttt{newInstance}
method, to retrieve specific constructors via the
\texttt{getConstructor} method, to analyze class methods and
fields, and for other above-mentioned meta-services: a sketch is
reported in \xf{dynamic-compilation}.
%
The \texttt{java\_class} arguments in the example specify, besides
the source text and the binding variable, the full class name
(\texttt{Counter}), which is necessary to locate the class in the
package hierarchy, and possibly a list of class paths required
for a successful compilation (if any).

\begin{figure}
\caption{Predicate \texttt{java\_class} performing dynamic compilation of Java code in \tuprolog{}.
\labelfig{dynamic-compilation}}
\begin{verbatim}
    ?- Source = 'public class Counter { ... }',
       java_class(Source, 'Counter', [], counterClass),
       counterClass <- newInstance returns myCounter,
       myCounter <- setValue(5),
       myCounter <- getValue returns X,
       write(X).
\end{verbatim}
\end{figure}

\xf{jcexamples} shows a more complex example, where a Java source
is retrieved via FTP and then exploited first to create a new
(previously unknown) class, and then a new instance of that class.
(The FTP service is provided by a shareware Java library.)
%
\begin{figure}
\caption{A new Java class is compiled and used after being retrieved via FTP.
\labelfig{jcexamples}}
{\scriptsize
\begin{verbatim}
% A user whose name is 'myName' and whose password is 'myPwd' gets the content of the file
% 'Counter.java' from the server whose IP address is 'srvAddr', creates the corresponding
% Java class and exploits it to instantiate and deploy an object

test :-
    get_remote_file('alice/tuprolog/test', 'Counter.java', srvAddr, myName, myPwd, Content),
    % creating the class
    java_class(Content, 'Counter', [], CounterClass),
    % instantiating (and using) an object of such a class
    CounterClass <- newInstance returns MyCounter,
    MyCounter <- setValue(303),
    MyCounter <- inc,
    MyCounter <- inc,
    MyCounter <- getValue returns Value,
    write(Value), nl.

% +DirName: Directory on the server where the file is located
% +FileName: Name of the file to be retrieved
% +FTPHost: IP address of the FTP server
% +FTPUser: User name of the FTP client
% +FTPPwd: Password of the FTP client
% -Content: Content of the retrieved file

get_remote_file(DirName, FileName, FTPHost, FTPUser, FTPPwd, Content) :-
    java_object('com.enterprisedt.net.ftp.FTPClient', [FTPHost], Client),
    % get file
    Client <- login(FTPUser, FTPPwd),
    Client <- chdir(DirName),
    Client <- get(FileName) returns Content,
    Client <- quit.
\end{verbatim}
}
\end{figure}
%
Though a lot remains to explore, \texttt{java\_class} features
seem quite interesting: in perspective one might think, for
instance, of a Prolog intelligent agent that dynamically acquires
information on a Java resource, and then autonomously builds up,
at run-time, the proper Java machinery enabling efficient
interaction with the resource.

%=======================================================================
\subsection{Handling Java Exceptions}
\label{ssec:java-exceptions-in-tuprolog}
%=======================================================================

One peculiar \tuprolog{} aspect concerns the handling of Java exceptions possibly raised during the execution of Java methods on objects accessed from the Prolog world via Javalibrary.

At a first sight, one might think of re-mapping Java exceptions and constructs onto the Prolog one, but this approach would have been unsatisfactory for three reasons:
%
\begin{itemize}
  \item the semantics of the Java mechanism should not be mixed with the Prolog one, and vice-versa;

  \item the Java construct admits also a \texttt{finally} clause which has no counterpart in ISO Prolog;

  \item the Java catching mechanisms operates hierarchically, while the \texttt{catch/3} predicate operates via pattern matching and unification, allowing for multiple granularities.
\end{itemize}

\noindent Accordingly, Java exceptions in \tuprolog{} programs are handled by means of two further, \textit{ad hoc} predicates, which are clearly not present in ISO Prolog: \texttt{java\_throw/1} and \texttt{java\_catch/3}.

\medskip

\noindent\textbf{Syntax:}

 \texttt{java\_throw(\textit{JavaException}(\textit{Cause}, \textit{Message}, \textit{StackTrace}))}

\medskip
\noindent where \textit{JavaException} is named after the specific Java exception to be launched
(e.g., \texttt{'java.io.FileNotFoundException'}, and its three arguments represent the typical
properties of any Java exception. More precisely, \texttt{\textit{Cause}} is a string representing
the cause of the exception, or \texttt{0} if the cause is unknown; \texttt{\textit{Message}} is
the message associated to the error (or, again, \texttt{0} if the message is missing);
\texttt{\textit{StackTrace}} is a list of strings, each representing a stack frame.

The \texttt{java\_catch/3} predicate takes the form
\medskip

 \texttt{java\_catch(\textit{JGoal}, [(\textit{Catcher1}, \textit{Handler1}),}

 \texttt{\mbox{~~~~~~~~~~~~~~~~~~}\ldots},

 \texttt{\mbox{~~~~~~~~~~~~~~~~~~}(\textit{CatcherN}, \textit{HandlerN})], \textit{Finally})}

\medskip
\noindent where \texttt{\textit{JGoal}} is the goal (representing a Java operation in the Java
world) to be executed under the protection of the handlers specified in the subsequent list, each
associated to a given type of Java exception and expressed in the form
\texttt{java\_exception(\textit{Cause}, \textit{Message}, \textit{StackTrace})}, with the same
argument semantics explained above. The third argument \texttt{\textit{Finally}} expresses the
homonomous Java clause, and therefore represents the predicate to be executed at the very end
either of the \texttt{\textit{Goal}} or one of the \texttt{\textit{Handler}}s. If no such a clause
is actually needed, the conventional atom (\texttt{'0'}) has to be used as a placeholder.

The predicate behaviour can be informally expressed as follows. First, \textit{\texttt{JGoal}} is
executed. Then, if no exception is raised via \texttt{java\_throw/1}, the
\texttt{\textit{Finally}} goal is executed. If, instead, an exception is raised, all the
choicepoints generated by \textit{\texttt{JGoal}} (in the case of a non-deterministic predicate
like \texttt{java\_object\_bt/3}, of course) are cut: if a matching handler exists, such a handler
is executed, maintaining the variable substitutions. If, instead, no such a handler is found, the
resolution tree is backsearched, looking for a matching \texttt{java\_catch/3} clause: if none
exists, the predicate fails. Upon completion, the \texttt{\textit{Finally}} part is executed
anyway, then the program flow continues with the subgoal following \texttt{java\_catch/3}. As
already said above, side effects possibly generated during the execution of
\textit{\texttt{JGoal}} are \textit{not} undone in case of exception.

So, summing up, \texttt{java\_catch/3} is true if:
\begin{itemize}
  \item \texttt{\textit{JGoal}} and \texttt{\textit{Finally}} are both true;\\\\or
  \item \texttt{call(\textit{JGoal})} is interrupted by a call to \texttt{java\_throw/1} whose
      argument unifies with one of the \texttt{\textit{Catcher}}s, and both the execution of
      the catcher and of the \texttt{\textit{Finally}} clause are true.
\end{itemize}

Even if \texttt{\textit{JGoal}} is a non-deterministic predicate, like
\texttt{java\_object\_bt/3}, and therefore the goal itself can be re-executed in backtracking, in
case of exception only one handler is executed, then all the choicepoints generated by
\texttt{\textit{JGoal}} are removed: so, no further handler would ever be executed for that
exception. In other words, \texttt{java\_catch/3} only protects the execution of
\texttt{\textit{JGoal}}, \textit{not} the handler execution or the \texttt{\textit{Finally}}
execution.

%-----------------------------------------------------------------------
\subsubsection{Examples}\label{ssec:jexamples}
%-----------------------------------------------------------------------
First, let us consider the following program:
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
       [('java.lang.ClassNotFoundException'(Cause, Msg, StackTrace),
         write(Msg))],
       write(+++)).
\end{verbatim}
which tries to allocate an instance of \texttt{Counter}, bind it to the atom \texttt{c}, and -- if
everything goes well -- print the \texttt{'+++'} message on the standard output.
%
Indeed, this is precisely what happens if, at runtime, the class \texttt{Counter} is actually
available in the file system. However, it might also happen that, for some reason, the required
class is \textit{not} present in the file system when the above predicate is executed. Then, a
\texttt{'java.lang.ClassNotFoundException'(Cause, Msg, StackTrace)} exception is raised, no side
effects occur -- so, no object is actually created -- and the \texttt{\textit{Msg}} is printed on
the standard output, followed by \texttt{'+++'} as required by the \texttt{\textit{Finally}}
clause. Since the \texttt{\textit{Msg}} in this exception is the name of the missing class, the
global message printed on the console is \texttt{Counter+++}.

\smallskip
In the following we report a small yet complete set of mini-examples, thought to put in evidence
one single aspect of \tuprolog{} compliance to the ISO standard.

%----------------
\medskip
\textit{\textbf{Example 1:} the handler must be executed maintaining the substitutions made during
the unification process between the exception and the catcher: then, the \texttt{Finally} part
must be executed.}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
       [('java.lang.ClassNotFoundException'(Cause, Message, _),
         X is 2+3)], Y is 2+5).
\end{verbatim}

Answer: \texttt{ yes.}

Substitutions: \texttt{Cause/0}, \texttt{Message/'Counter'}, \texttt{X/5}, \texttt{Y/7}.

%----------------
\medskip
\textit{\textbf{Example 2:} the selected \texttt{java\_catch/3} must be the nearest in the
resolution tree whose second argument unifies with the launched exception}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
       [('java.lang.ClassNotFoundException'(Cause, Message, _),
         true], true),
    java_catch(java_object('Counter', ['MyCounter2'], c2),
       [('java.lang.ClassNotFoundException'(Cause2, Message2, _),
         X is 2+3], true).
\end{verbatim}

Answer: \texttt{ yes.}

Substitutions: \texttt{Cause/0}, \texttt{Message/'Counter'}, \texttt{X/5}, \texttt{C/0},
\texttt{Message2/'Counter'}.

%----------------
\medskip
\textit{\textbf{Example 3:} execution must fail if an exception is raised during the execution of
a goal and no matching \texttt{java\_catch/3} can be found}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
      [('java.lang.Exception'(Cause, Message, _), true)], true)).
\end{verbatim}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 4:} \texttt{java\_catch/3} must fail if the handler is false}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
      [('java.lang.Exception'(Cause, Message, _), false)], true)).
\end{verbatim}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 5:} \texttt{java\_catch/3} must fail also if an exception is raised during
the execution of the handler}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
      [('java.lang.ClassNotFoundException'(Cause, Message, _),
        java_object('Counter', ['MyCounter'], c))], true).
\end{verbatim}

Answer: \texttt{ no.}

%----------------
\medskip
\textit{\textbf{Example 6:} the \textit{\texttt{Finally}} must be executed also in case of success
of the goal}
\begin{verbatim}
 ?- java_catch(java_object('java.util.ArrayList', [], l),
       [E, true], X is 2+3).
\end{verbatim}

Answer: \texttt{ yes.}

Substitutions: \texttt{X/5}.

%----------------
\medskip
\textit{\textbf{Example 7:} the \textit{\texttt{Handler}} to be executed must be the proper one
among those available in the handlers' list}
\begin{verbatim}
 ?- java_catch(java_object('Counter', ['MyCounter'], c),
     [('java.lang.Exception'(Cause, Message, _), X is 2+3),
      ('java.lang.ClassNotFoundException'(Cause, Message, _), Y is 3+5)],
      true).
\end{verbatim}

Answer: \texttt{ yes.}

Substitutions: \texttt{Cause/0}, \texttt{Message/'Counter'}, \texttt{Y/8}.


%-----------------------------------------------------------------------
\section{Using Prolog from Java: \textit{the Java API}}
\label{sec:java-api}
%-----------------------------------------------------------------------

\subsection{Getting started}

Let's begin with your first Java program using \tuprolog{}.
%
{\small{
\begin{verbatim}
    import alice.tuprolog.*;

    public class Test2P {
        public static void main(String[] args) throws Exception {
            Prolog engine = new Prolog();
            SolveInfo info = engine.solve("append([1],[2,3],X).");
            System.out.println(info.getSolution());
        }
    }
\end{verbatim}
}}
\noindent In this first example a \tuprolog{} engine is
created, and asked to solve a query, provided in a textual form.
%
This query in the Java environment is equivalent to the query\\\\
%
{\small{\texttt{?- append([1],[2,3],X).\\\\}}}
%
\noindent in a classic Prolog environment, and accounts for
finding the list that is obtained by appending the list
\texttt{[2,3]} to the list \texttt{[1]} (\texttt{append} is
included in the theory provided by the
\texttt{alice.tuprolog.lib.BasicLibrary}, which is downloaded by
the default when instantiating the engine).
%

By properly compiling and executing this simple program,\footnote{Save the program in a file called \texttt{Test2P.java}, then compile it with
%
\texttt{javac -classpath tuprolog.jar Test2P.java}
%
and then execute it with
%
\texttt{java -cp .;tuprolog.jar Test2P.java}} the string
\texttt{append([1],[2,3],[1,2,3])} -- that is the solution of out
query -- will be displayed on the standard output.
%
%

\noindent Then, let's consider a little bit more involved example:

{\small{
\begin{verbatim}
public class Test2P {
    public static void main(String[] args) throws Exception {
        Prolog engine = new Prolog();
        SolveInfo info = engine.solve("append(X,Y,[1,2]).");
        while (info.isSuccess()) {
            System.out.println("solution: " + info.getSolution() +
                               " - bindings: " + info);
            if (engine.hasOpenAlternatives()) {
                info = engine.solveNext();
            } else {
                break;
            }
        }
    }
}
\end{verbatim}
}}

In this case, all the solutions of a query are retrieved and
displayed, with also the variable bindings:
{\small{\begin{verbatim}

solution: append([],[1,2],[1,2]) - bindings: Y / [1,2]  X / []
solution: append([1],[2],[1,2]) - bindings: Y / [2]  X / [1]
solution: append([1,2],[],[1,2]) - bindings: Y / []  X / [1,2]

\end{verbatim}
}}

%-----------------------------
\subsection{Basic Data Structures}
\label{ssec:java-api-types}
%-----------------------------

\noindent All Prolog data objects are mapped onto Java objects:
\texttt{Term} is the base class for Prolog untyped terms such as
atoms and compound terms (represented by the \texttt{Struct} class),
Prolog variables (\texttt{Var} class) and Prolog typed terms such
as numbers (\texttt{Int}, \texttt{Long}, \texttt{Float},
\texttt{Double} classes).
%
In particular:

%
\begin{itemize}
    %
    \item \texttt{Term} -- this abstract class represents a generic Prolog term, and it is the
    root base class of \tuprolog{} data structures, defining the basic common services, such
    as term comparison, term unification and so on.
    %
    It is worth noting that it is an abstract class, so no direct \texttt{Term}
    objects can be instantiated;
    %
    %
    %
    \item \texttt{Var} -- this class (derived from \texttt{Term})
    represents \tuprolog{} variables.
    %
    A variable can be anonymous, created by means of the default constructor, with no
    arguments, or identified by a name, that must starts with an upper case letter or an
    underscore;
    %
    \item \texttt{Struct} -- this class (derived from \texttt{Term})
    represents un-typed \tuprolog{} terms, such as atoms, lists and compound terms;
    %
    \texttt{Struct} objects are characterised by a functor name and a
    list of arguments (which are \texttt{Term}s themselves), while
    \texttt{Var} objects are labelled by a string representing the
    Prolog name.
    %
    Atoms are mapped as \texttt{Struct}s with functor with a name and
    no arguments;
    %
    Lists are mapped as \texttt{Struct} objects with functor
    \verb|'.'|, and two \texttt{Term} arguments (head and tail of the list);
    %
    lists can be also built directly by exploiting the 2-arguments constructor, with
    head and tail terms as arguments.
    %
    Empty list is constructed by means of the no-argument constructor of \texttt{Struct}
    (default constructor).
    %
    \item \texttt{Number} -- this abstract class represents typed, numerical Prolog terms,
        and it is the  base class of \tuprolog{} number classes;
    %
    \item \texttt{Int, Long, Double, Float} -- these classes (derived from \texttt{Number})
    represent  typed numerical \tuprolog{} terms, respectively integer, long, double and
    float numbers.
    %
    Following the Java conventions, the default type for integer number is \texttt{Int}
    (integer, not long, number), and for \texttt{Double} (and so double), for floating point
    number.
\end{itemize}


The general mapping between Prolog types and Java types has been summarized in Table \ref{tab:prolog-java-type-mapping} above. 

\textit{Although the Prolog language considers a comprehensive \texttt{number} type for both integer and real values, the two kinds have been considered separately in this table, both for the user's convenience and because \tuprolog{} internally does use different types for this purpose (indeed, the \tuprolog{} internal representation of numbers does distinguish \texttt{Number} into \texttt{Int}, \texttt{Long}, \texttt{Double} and \texttt{Float}, based on the value to be stored---details in Section \ref{ssec:java-api-types}).
%
More precisely, in the Prolog-to-Java direction, only the Java \texttt{int}, \texttt{long} and \texttt{double} types are used as target types for the mapping, while in the opposite Java-to-Prolog direction any of the numeric Java types are accepted (including \texttt{short}, \texttt{byte} and \texttt{float}) for mapping onto Prolog numbers.
}

\begin{enumerate}
  \item Prolog integers are mapped onto Java \texttt{int} or \texttt{long} types, as appropriate; in the opposite direction, Java \texttt{int} and \texttt{long} values are mapped onto Prolog integers (namely, onto \tuprolog{} inner \texttt{Int} and \texttt{Long} types, respectively);
  \item \texttt{byte} and \texttt{short} Java types are mapped into \tuprolog{}'s \texttt{Int} instances
\end{enumerate}

Boolean Java values are mapped into specific \tuprolog{} \texttt{Term} constants.
%
Java \texttt{char}s are mapped into Prolog atoms, but atoms are
mapped into Java \texttt{String}s by default.
%
The \emph{any} variable (\_) can be used to specify the Java
\texttt{null} value.


\noindent \textbf{Some examples of term creation} follow:
%
{\small{\begin{verbatim}

// constructs the atom vodka
Struct drink = new Struct("vodka");

// constructs the number 40
Term degree = new alice.tuprolog.Int(40);

// constructs the compound degree(vodka, 40)
Term drinkDegree = new Struct("degree",
                              new Struct("vodka"),
                              new Int(40));
// second way to constructs the compound degree(vodka,40)
Struct drinkDegree2 = new Struct("degree", drink, degree);

// constructs the compound temperature('Rome', 25.5)
Struct temperature = new Struct("temperature",
                                new Struct("Rome"),
                                new alice.tuprolog.Float(25.5));

// constructs the compound equals(X, X)
Struct t1 = new Struct("equals", new Var("X"), new Var("X"));
t1.resolveTerm();

// mother(John,Mary)
Struct father = new Struct(new Struct("John"), new Struct("Mary")));

// father(John, _)
Term  father = new Struct(new Struct("John"), new Var());

// p(1, _, q(Y, 3.03, 'Hotel'))
Term  t2 = new Struct("p",
                      new Int(1),
                      new Var(),
                      new Struct("q",
                                 new Var("Y"),
                                 new Float(3.03f),
                                 new Struct("Hotel")));

// The Long number 130373303303
Term t3 = new alice.tuprolog.Long(130373303303h);

// The double precision number 1.7625465346573
Term t4 = new alice.tuprolog.Double(1.7625465346573);

// an empty list
Struct empty = new Struct();

// the list [303]
Struct l = new Struct(new Int(303), new Struct());

// the list [1,2,apples]
Struct alist = new Struct(
                   new Int(1),
                   new Struct(
                       new Int(2),
                       new Struct("apples")));

// fruits([apple, orange | _ ])
Term list2 = new Struct("fruits", new Struct(
                                      new Struct("apple",
                                          new Struct("orange"),
                                          new Var())));

// complex_compound(1, _, q(Y, 3.03, 'Hotel', k(Y,X)), [303, 13, _, Y])
Term t5 = Term.parse(
     "complex_compound(1, _, q(Y, 3.03, 'Hotel', k(Y,X)), [303, 13, _, Y])"
);

\end{verbatim}}}
%
\noindent The name of the \tuprolog{} number classes
(\texttt{Int}, \texttt{Float}, \texttt{Long}, \texttt{Double})
follows the name of the primitive Java data type they represents.
%
Note that due to class name clashes (for instance between classes
\texttt{java.lang.Long} and \texttt{alice.tuprolog.Long}), it
could be necessary to use the full class name to identify
\tuprolog{} classes.
%

\subsection{Engine, Theories and Libraries}

\noindent Then, the other main classes that make \tuprolog{} Core
API concern \tuprolog{} engines, theories and libraries. In
particular:
%
\begin{itemize}
    \item \texttt{Prolog} -- this class represent \tuprolog{}
    engines.
    %
    This class provides a minimal interface that enables users
    to: \\
    %
    \indent{-- set/get the theory to be used for
    demonstrations;}\\
        %
    \indent{-- load/unload libraries;} \\
        %
    \indent{-- solve a goal, represented either by a \texttt{Term} object or by a
        textual representation (a \texttt{String} object) of a
        term.}\\
    %
    A \tuprolog{} engine can be instantiated either with some standard default
    libraries loaded, by means of the default constructor, or with
    a starting set of libraries, which can be empty, provided as
    argument to the constructor (see JavaDoc documentation for
    details).
    %
    Accordingly, a raw, very lightweight, \tuprolog{} engine can
    be created by specifying an empty set of library, providing
    natively a very small set of built-in primitives.


    \item \texttt{Theory} -- this class represent \tuprolog{}
    theories.
    %
    A theory is represented by a text, consisting of a series of
    clauses and/or directives, each followed by a dot and a
    whitespace character.
    %
    Instances of this class are built either from a textual representation,
    directly provided as a string or taken by any possible input
    stream, or from a list of terms representing Prolog clauses.
    %
    %
    %
    %
    %
    \item \texttt{Library} -- this class represents \tuprolog{}
    libraries;
    %
    A \texttt{tuprolog} engine can be dynamically extended by loading
    (and unloading) any number of libraries; each library can provide
    a specific set of of built-ins predicates, functors and a related
    theory.
    %
    A library can be loaded by means of the built-in by means of the method
    \texttt{loadLibrary} of the \tuprolog{} engine.
    %
    Some standard libraries are provided in the
    \texttt{alice.tuprolog.lib} package and loaded by the default
    instantiation of a \tuprolog{} engine:
    %
    \texttt{alice.tuprolog.lib.BasicLibrary}, providing basic and
    well-known Prolog built-ins, \texttt{alice.tuprolog.lib.IOLibrary}
    providing \textit{de facto} standard Prolog I/O predicates, \texttt{alice.tuprolog.lib.ISOLibrary}
    providing some ISO predicates/functors not directly provided
    by \texttt{BasicLibrary} and \texttt{IOLibrary}, and
    \texttt{alice.tuprolog.lib.JavaLibrary}, which enables the
    creation and usage of Java objects from \tuprolog{} programs,
    in particular enabling the reuse of any existing Java resources.
    %
    %
    \item \texttt{SolveInfo} -- this class represents the result of a
    demonstration and instances of these class are returned by the
    \texttt{solve} methods the \texttt{Prolog} engines;
    %
    in particular \texttt{SolveInfo} objects provide services to test the
    success of the demonstration (\texttt{isSuccess} method),
    to access to the term solution of the query
    (\texttt{getSolution} method)  and to access the list of the
    variable with their bindings.
\end{itemize}
%

Some notes about \tuprolog{} terms and the services they provide:
\begin{itemize}
%
\item the static \texttt{parse} method provides a quick way to get a
term from its string representation.
%
\item \tuprolog{} terms provides directly methods for unification and matching: \\
%
{\tt{\small{public boolean unify(Term t)}}}\\
%
{\tt{\small{public boolean match(Term t)}}}\\
%
Terms that have been subject to unification outside a
demonstration context (that is invoking directly these methods,
and not passing through the solving service of an engine) should
not be used then in queries to engines.
%
\item some services are provided to compare terms, according to the
Prolog rules, and to check their type;
%
in particular the standard Java method \texttt{equals} has the
same semantics of the method \texttt{isEqual} which follows the
Prolog comparison semantics.
%
\item some services makes it possible to copy a term as it is
or to get a renamed copy of the term (\texttt{copy} and
\texttt{getRenamedCopy});
%
it is worth noting that the design of \tuprolog{} promotes a
stateless usage of terms; in particular, it is good practice not
to reuse the same terms in different demonstration contexts, as
part of different queries.
%
\item the method \texttt{getTerm} is useful in the case of
variables, providing the term linked possibly considering all the
linking chain in the case of variables referring other variables.
%
\item when a term is created by means of the proper constructor,
consider as example: \\\\
%
{\tt{\scriptsize{Struct myTerm = new Struct("p", new Var("X"), new
Int(1), new Var("X"))}}}\\\\
%
it is \emph{not resolved}, in the sense that possible variable
terms with the same name in the term do not refer each other;
%
so in the example the first and the third argument of the compound
\texttt{myTerm} point to different variable objects.
%
A term is resolved the first time it is involved in a matching or
unification context.
%
\end{itemize}

\noindent Some notes about \tuprolog{} engines, theories,
libraries and the services they provide:

\begin{itemize}
%
\item \tuprolog{} engines support natively some
\emph{directives}, that can be defined by means of the :-/1
predicate in theory specification.
%
Directives are used to specify properties of clauses and of the
engine (\emph{solve/1}, \emph{initialization/1},
\emph{set\_prolog\_flag/1}, \emph{load\_library/1},
\emph{consult/1}), format and syntax of read-terms (\emph{op/3},
\emph{char\_conversion/2}).
%
\item \tuprolog{} engines support natively the dynamic definition
and management of \emph{flags} (or property), used to describe
some aspects of libraries and their built-ins.
%
A flag is identified by a name (an alphanumeric atom), a list of
possible values, a default value and a boolean value specifying if
the flag value can be modified.
%
\item \tuprolog{} engines are thread-safe. The methods that could
create problems in being used in a multi-threaded context are now
synchronised.
%
\item \tuprolog{} engines have no (static) dependencies with each
other, multiple engines can be created independently as simple
objects on the same Java virtual machine,  each with its own
configuration (theory and loaded libraries).
%
Moreover, accordingly to the design of \tuprolog{} system in
general, engines are very lightweight, making suitable the use of
multiple engines in the same execution context.
%
\item \tuprolog{} engines can be serialised and stored as a persistent
object or sent through the network.
%
This is true also for engines with pre-loaded standard libraries:
%
in the case that other libraries are loaded, these must be
serializable in order to have the engine serializable.
%
\end{itemize}


\subsection{Examples}

\noindent Creation of an engine (with default libraries pre-loaded):

{\tt\scriptsize{
\begin{verbatim}
    import alice.tuprolog.*;

    ...
    Prolog engine = new Prolog();
\end{verbatim} }}


\noindent Creation of an engine specifying only the
\texttt{BasicLibrary} as pre-loaded library:

{\tt\scriptsize{
\begin{verbatim}
    import alice.tuprolog.*;

    ...
    Prolog engine = new Prolog(new String[]{"alice.tuprolog.lib.BasicLibrary"});
\end{verbatim} }}

\noindent Creation and loading of a theory from a string:

{\tt\scriptsize{\begin{verbatim}

    String theoryText = "my_append([],X,X).\n" +
                        "my_append([X|L1],L2,[X|L3]) :- my_append(L1,L2,L3).\n";

    Theory theory = new Theory(theoryText);
    try {
        engine.setTheory(theory);
    } catch(InvalidTheoryException e) {
    }
\end{verbatim} }}

\noindent Creation and loading of a theory from an input stream:

{\tt\scriptsize{\begin{verbatim}

    Theory theory = new Theory(new FileInputStream("test.pl");
    try {
        engine.setTheory(theory);
    } catch(InvalidTheoryException e) {
    }
\end{verbatim} }}

\noindent Goal demonstration (provided as a string):

{\tt\scriptsize{\begin{verbatim}

    // ?- append(X,Y,[1,2,3]).
    try {
        SolveInfo info = engine.solve("append(X,Y,[1,2,3]).");
        Term solution = info.getSolution();
    } catch(MalformedGoalException mge) {
        ...
    } catch(NoSolutionException nse) {
        ...
    }
\end{verbatim} }}

\noindent Goal demonstration (provided as a Term):

{\tt\scriptsize{\begin{verbatim}

    try {
        Term goal = new Struct("p", new Int(1), new Var("X"));
        try {
            // ?- p(1,X).
            SolveInfo info = engine.solve(goal);
            Term solution = info.getSolution();

        } catch (NoSolutionException nse) {
        }
    } catch (InvalidVarNameException ivne) {
    }
\end{verbatim} }}

\noindent Getting another solution:

{\tt\scriptsize{\begin{verbatim}
    try {
        SolveInfo info = engine.solve(goal);
        info = engine.solveNext();
    } catch(NoMoreSolutionException e)
\end{verbatim} }}

\noindent Loading a library:

{\tt\scriptsize{\begin{verbatim}
    try {
        engine.loadLibrary('alice.tuprologx.lib.TucsonLibrary');
    } catch(InvalidLibraryException e) {
    }
\end{verbatim} }}

\noindent Here, a complete example of interaction with a
\tuprolog{} engine is shown (refer to the JavaDoc documentation for
details about interfaces):

{\tt\scriptsize{\begin{verbatim}

import alice.tuprolog.*; import java.io.*;

public class Test2P {
    public static void main (String args[]) {
        Prolog engine = new Prolog();
        try {

            // solving a goal
            SolveInfo info = engine.solve(new Struct("append",
                                              new Var("X"),
                                              new Var("Y"),
                                              new Struct(new Term[]{new Struct("hotel"),
                                                                    new Int(303),
                                                                    new Var()})));


            // note we could use strings:
            // SolveInfo info = engine.solve("append(X, Y, [hotel, 303, _]).");

            // test for demonsration success
            if (info.isSuccess()) {

                // acquire solution and substitution
                Term sol = info.getSolution();
                System.out.println("Solution: " + sol);

                System.out.println("Bindings: " + info);

                // open choice points?
                if (engine.hasOpenAlternatives()) {

                    // ask for another solution
                    info = engine.solveNext();

                    if (info.isSuccess()) {
                        System.out.println("An other substitution: " + info);
                    }
                }
            }

            // other frequent interactions

            // setting a new theory in the engine
            String theory = "p(X,Y) :- q(X), r(Y).\n" +
                            "q(1).\n" +
                            "r(1).\n" +
                            "r(2).\n";
            engine.setTheory(new Theory(theory));

            SolveInfo info2 = engine.solve("p(1,X).");
            System.out.println(info2);

            // retrieving the theory from a file
            FileOutputStream os=new FileOutputStream("test.pl");
            os.write(theory.getBytes());
            os.close();
            engine.setTheory(new Theory(new FileInputStream("test.pl")));
            info2 = engine.solve("p(X,X).");
            System.out.println(info2.getSolution());

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
\end{verbatim}}}

With the program execution, the following string are displayed on
the standard output:

{\tt\small{

\begin{verbatim}
Solution: append([],[hotel,303,_],[hotel,303,_])
Bindings: Y /[hotel,303,_] X / []
An other substitution: Y / [303,_]  X / [hotel]
X / 1
p(1,1)
\end{verbatim}}} 

%-----------------------------------------------------------------------
\section{Augmenting Prolog from Java: \textit{developing new libraries}}
\label{sec:howto-develop-libraries}
%-----------------------------------------------------------------------

Libraries are \tuprolog{}'s way to achieve the desired characteristics
of minimality, dynamic configurability, and straightforward
Prolog-to-Java integration.
%
Libraries are reflection-based, and can be written both in Prolog
and Java: other languages may be used indirectly, via JNI (Java
Native Interface).
%
At the \tuprolog{} side, exploiting a library written in Java
requires no pre-declaration of the new built-ins, nor any other
special mechanism: all is needed is the presence of the
corresponding \texttt{.class} library file in the proper location
in the file system.

\subsection{Implementation details}

Syntactically, a library developed in Java must extend the base
abstract class \texttt{alice.tuprolog.Library}, provided within
the \tuprolog{} package, and define new \textit{predicates} and/or
\textit{evaluable functors} and/or \textit{directives} in the form
of methods, following a simple signature convention.
%
In particular, new predicates must adhere to the signature:
%
\begin{center}
\small\tt
    public boolean <\textit{pred name}>\_<\textit{N}>(\textit{T1} arg1,
\textit{T2} arg2, ...,\textit{Tn} argN)
\end{center}
%
while evaluable functors must follow the form:
%
\begin{center}
    \small\tt
    public Term <\textit{eval funct name}>\_<\textit{N}>(\textit{T1} arg1,
\textit{T2} arg2, ...,\textit{Tn} argN)
\end{center}
%
and directives must be provided with the signature:
%
\begin{center}
    \small\tt
    public void <\textit{dir name}>\_<\textit{N}>(\textit{T1} arg1,
\textit{T2} arg2, ..., \textit{Tn} argN)
\end{center}
%
where \textit{T1}, \textit{T2}, ... \textit{Tn} are \texttt{Term} or derived
classes, such as \texttt{Struct}, \texttt{Var}, \texttt{Long}, etc., defined in
the \tuprolog{} package, constituting  the Java counterparts of
the corresponding Prolog data types.
%
The parameters represent the arguments actually passed to the built-in
predicate, functor, or directive.

%
A library defines also a new piece of theory, which is collected
by the Prolog engine through a call to the library method \texttt{String
getTheory()}.
%
By default, this method returns an empty theory: libraries which need to
add a Prolog theory must override it accordingly.
%
Note that only the external representation of a library's theory is
constrained to be in \texttt{String} form; the internal implementation
can be freely chosen by the library designer. However, using a Java
\texttt{String} for wrapping a library's Prolog code guarantees
self-containment while loading libraries through remote mechanisms such
as RMI.

\begin{table}[h]
    %
    \caption{Predicate and functor definitions in Java and their use
    in a \tuprolog{} program.\labeltab{java-preds}}
    %
    \begin{center}{\small\tt
    \begin{tabular}{p{10cm}|p{3.25cm}}
     \hline
     & \\
    \textit{// sample library} & \textit{\% tuProlog test program}\\
     import alice.tuprolog.*; & \\
     & \\
    public class TestLibrary extends Library \{                            &
 test :-\\
    ~~\textit{// builtin functor sum(A,B)}                          & ~~N is sum(5,6),\\
    ~~public Term sum\_2(Number arg0, Number arg1)\{    & ~~println(N).\\
    ~~~~float   arg0 = arg0.floatValue();        & \\
    ~~~~float   arg1 = arg1.floatValue();        & \\
    ~~~~return new Float(arg0+arg1);                                & \\
    ~~\}                                                            & \\
    ~~\textit{// builtin predicate println(Message)}                & \\
    ~~public boolean println\_1(Term arg)\{                      & \\
    ~~~~System.out.println(arg);                                   & \\
    ~~~~return true;                                                & \\
    ~~\}                                                            & \\
    \}                                                              & \\
     & \\
     \hline
    \end{tabular}
    }\end{center}
\end{table}

\xt{java-preds} shows a couple of examples about how a predicate
(such as \texttt{println/1}) and an evaluable functor (such as
\texttt{sum/2}) can be defined in Java and exploited from
\tuprolog{}.
%
The Java method \texttt{sum\_2}, which implements the evaluable
functor \texttt{sum/2}, is passed two \texttt{Number} terms (5 and 6)
which are then used (via \texttt{getTerm}) to retrieve the two
(float) arguments to be summed.
%
In the same way, method \texttt{println\_1}, which implements the
predicate \texttt{println/1}, receives \texttt{N} as \texttt{arg},
and retrieves its actual value via \texttt{getTerm}: since this is
a predicate, a boolean value (\texttt{true} in this case) is returned.
%

The developer of a library may face two corner case as far as method
naming is concerned: the first happens when the name of the
predicate, functor or directive she is defining contains a symbol
which cannot legally appear in a Java method's name; the second
occurs when he has to define a predicate and a directive with the
same Prolog signature, which Java would not be able to tell apart
because it cannot distinguish signatures of methods differing for
their return type only.
%
To overcome this kind of issues, a {\em synonym map} can be
constructed under the form of an array of \texttt{String} arrays,
and returned by the appropriate \texttt{getSynonymMap} method,
defined as abstract by the \texttt{Library} class. In both the cases
described above, another name must be chosen for the Prolog
executable element the library's developer want to define: then, by
means of the synonym map, that fake name can be associated with the
real name and the type of the element, be it a predicate, a functor
or a directive.
%
For example, if a definition for an evaluable functor representing
addition is needed, but the symbol \texttt{+} cannot appear in a
Java method's name, a method called \texttt{add} can be defined and
associated to its original Prolog name and its function by inserting
the array \texttt{\{"+", "add", "functor"\}} in the synonym map.

\subsection{Library Name}

% Lib name
%
By default, the name of the library coincides with the full class name of the
class implementing it.
%
However, it is possible to define explicitly the name of a library by
overriding the \texttt{getName} method, and returning as a string
the real name.
%
For example:
%
\begin{verbatim}
package acme;
import alice.tuprolog.*;
public class MyLib_ver00 extents Library {
    public String getName(){
        return "MyLibrary";
    }
    ...
}
\end{verbatim}

This class defines a library called \texttt{MyLibrary}.
%
It can be loaded into a Prolog engine by using the
\texttt{loadLibrary} method on the Java side, or a
\texttt{load\_library} built-in predicate on the Prolog side,
specifying the full class name (\texttt{acme.MyLib\_{ve00}}).
%
It can be unloaded then dynamically using the \texttt{unloadLibrary}
method (or the corresponding \texttt{unload\_library} built-in),
specifying instead the \textit{library name} (\texttt{MyLibrary}).

%-----------------------------------------------------------------------
\section{Augmenting Java from Prolog: \textit{the P@J framework}}
\label{sec:p@j}
%-----------------------------------------------------------------------

to be written (take from DORV-Multiparadigm)
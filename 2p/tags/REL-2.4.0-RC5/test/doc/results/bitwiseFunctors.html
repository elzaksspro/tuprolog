<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<title>Bitwise functors</title>
</head>

<body>

<h1>Bitwise functors</h1>

<p>The operands and value of these evaluable functors are integers which are treated as a binary sequences of bits. The value is implementation defined when an operand or value is negative because the representation of a negative integer is implementation defined.</p>

<p>Templates and modes represent a specification for the type of the values when the arguments of the evaluable functor are evaluated as an expression, and the type of its value. A specific notation is employed for the structure and type of the arguments and value:</p>
<ul>
  <li><var>int-exp</var> represents an integer expression,</li>
  <li><var>integer</var> identifies an integer value,</li>
  <li><var>float-exp</var> represents a floating point expression,</li>
  <li><var>float</var> identifies a floating point value.</li>
</ul>

<h2>1. <code>(>>)/2</code> (bitwise right shift) </h2>

<p><code>'>>'(N, S)</code> evaluates the expressions <var>N</var> and <var>S</var> with values <var>VN</var> and <var>VS</var> and has the value of <var>VN</var> right-shifted <var>VS</var> bit positions.</p>

<p>The value shall be implementation defined depending on whether the shift is logical (fill with zeros) or arithmetic (fill with a copy of the sign bit).</p>

<p>The value shall be implementation defined if <var>VS</var> is negative, or <var>VS</var> is larger than the bit size of an integer.</p>

<p>Templates and modes for the predicate are as follows:</p>
<pre>
'>>'(int-exp, int-exp) = integer
</pre>

<p>Note that <code>>></code> is an infix predefined operator.</p>

<h3>1.1 Example tests</h3>

<p>First of all, let's start an appropriate fixture.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="2">fit.ActionFixture</td>
  </tr>
  <tr>
    <td>start</td>
    <td>alice.tuprolog.EvaluationFixture</td>
  </tr>
</table>

<p>Then, ask the engine to evaluate an expression and verify the result.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="3">alice.tuprolog.PrologActionFixture</td>
  </tr>
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'>>'(16, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#cfffcf">4</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'>>'(19, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#cfffcf">4</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'>>'(-16, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td> <font color="#808080">-4</font></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'>>'(77, N).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">instantiation_error</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'>>'(foo, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">type_error(integer, foo)</td>
  </tr>
</table>

<h2>2. <code>(&lt;&lt;)/1</code> (bitwise left shift)</h2>

<p><code>'&lt;&lt;'(N, S)</code> evaluates the expressions <var>N</var> and <var>S</var> with values <var>VN</var> and <var>VS</var> and has the value of <var>VN</var> left-shifted <var>VS</var> bit positions, where the <var>VS</var> least significant bit positions of the result are zero.</p>

<p>The value shall be implementation defined if <var>VS</var> is negative, or <var>VS</var> is larger than the bit size of an integer.</p>

<p>Templates and modes for the predicate are as follows:</p>
<pre>
'&lt;&lt;'(int-exp, int-exp) = integer
</pre>

<p>Note that <code>&lt;&lt;</code> is an infix predefined operator.</p>

<h3>2.1 Example tests</h3>

<p>First of all, let's start an appropriate fixture.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="2">fit.ActionFixture</td>
  </tr>
  <tr>
    <td>start</td>
    <td>alice.tuprolog.EvaluationFixture</td>
  </tr>
</table>

<p>Then, ask the engine to evaluate an expression and verify the result.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="3">alice.tuprolog.PrologActionFixture</td>
  </tr>
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'&lt;&lt;'(16, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#cfffcf">64</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'&lt;&lt;'(19, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#cfffcf">76</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'&lt;&lt;'(-16, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td> <font color="#808080">-64</font></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'&lt;&lt;'(77, N).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">instantiation_error</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'&lt;&lt;'(foo, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">type_error(integer, foo)</td>
  </tr>
</table>

<h2>3. <code>(/\)/2</code> (bitwise and)</h2>

<p><code>'/\\'(B1, B2)</code> evaluates the expressions <var>B1</var> and <var>B2</var> with values <var>VB1</var> and <var>VB2</var> and has the value such that each bit is set iff each of the corresponding bits in <var>VB1</var> and <var>VB2</var> is set.</p>

<p>The value shall be implementation defined if <var>VB1</var> or <var>VB2</var> is negative.</p>

<p>Templates and modes for the predicate are as follows:</p>
<pre>
'/\\'(int-exp, int-exp) = integer
</pre>

<p>Note that <code>/\</code> is an infix predefined operator.</p>

<h3>3.1 Example tests</h3>

<p>First of all, let's start an appropriate fixture.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="2">fit.ActionFixture</td>
  </tr>
  <tr>
    <td>start</td>
    <td>alice.tuprolog.EvaluationFixture</td>
  </tr>
</table>

<p>Then, ask the engine to evaluate an expression and verify the result.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="3">alice.tuprolog.PrologActionFixture</td>
  </tr>
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'/\\'(10, 12).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#ffffcf">8<hr><pre>alice.tuprolog.NoSolutionException<br />	at alice.tuprolog.SolveInfo.getVarValue(SolveInfo.java:171)<br />	at alice.tuprolog.EvaluationFixture.value(EvaluationFixture.java:22)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.TypeAdapter.invoke(Unknown Source)<br />	at fit.TypeAdapter.get(Unknown Source)<br />	at fit.Fixture.check(Unknown Source)<br />	at alice.tuprolog.PrologActionFixture.check(PrologActionFixture.java:18)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.ActionFixture.doCells(Unknown Source)<br />	at fit.Fixture.doRow(Unknown Source)<br />	at fit.Fixture.doRows(Unknown Source)<br />	at fit.Fixture.doTable(Unknown Source)<br />	at fit.Fixture.interpretFollowingTables(Unknown Source)<br />	at fit.Fixture.interpretTables(Unknown Source)<br />	at fit.Fixture.doTables(Unknown Source)<br />	at fit.FileRunner.process(Unknown Source)<br />	at fit.FileRunner.run(Unknown Source)<br />	at fit.FileRunner.main(Unknown Source)<br /></pre></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>/\(10, 12).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#ffffcf">8<hr><pre>alice.tuprolog.MalformedGoalException<br />	at alice.tuprolog.Prolog.solve(Prolog.java:407)<br />	at alice.tuprolog.EvaluationFixture.value(EvaluationFixture.java:21)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.TypeAdapter.invoke(Unknown Source)<br />	at fit.TypeAdapter.get(Unknown Source)<br />	at fit.Fixture.check(Unknown Source)<br />	at alice.tuprolog.PrologActionFixture.check(PrologActionFixture.java:18)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.ActionFixture.doCells(Unknown Source)<br />	at fit.Fixture.doRow(Unknown Source)<br />	at fit.Fixture.doRows(Unknown Source)<br />	at fit.Fixture.doTable(Unknown Source)<br />	at fit.Fixture.interpretFollowingTables(Unknown Source)<br />	at fit.Fixture.interpretTables(Unknown Source)<br />	at fit.Fixture.doTables(Unknown Source)<br />	at fit.FileRunner.process(Unknown Source)<br />	at fit.FileRunner.run(Unknown Source)<br />	at fit.FileRunner.main(Unknown Source)<br /></pre></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'/\\'(17 * 256 + 125, 255).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#ffffcf">125<hr><pre>alice.tuprolog.NoSolutionException<br />	at alice.tuprolog.SolveInfo.getVarValue(SolveInfo.java:171)<br />	at alice.tuprolog.EvaluationFixture.value(EvaluationFixture.java:22)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.TypeAdapter.invoke(Unknown Source)<br />	at fit.TypeAdapter.get(Unknown Source)<br />	at fit.Fixture.check(Unknown Source)<br />	at alice.tuprolog.PrologActionFixture.check(PrologActionFixture.java:18)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.ActionFixture.doCells(Unknown Source)<br />	at fit.Fixture.doRow(Unknown Source)<br />	at fit.Fixture.doRows(Unknown Source)<br />	at fit.Fixture.doTable(Unknown Source)<br />	at fit.Fixture.interpretFollowingTables(Unknown Source)<br />	at fit.Fixture.interpretTables(Unknown Source)<br />	at fit.Fixture.doTables(Unknown Source)<br />	at fit.FileRunner.process(Unknown Source)<br />	at fit.FileRunner.run(Unknown Source)<br />	at fit.FileRunner.main(Unknown Source)<br /></pre></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>/\(-10, 12).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td> <font color="#808080">error</font></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'/\\'(77, N).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">instantiation_error</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'/\\'(foo, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">type_error(integer, foo)</td>
  </tr>
</table>

<h2>4. <code>(\/)/2</code> (bitwise or)</h2>

<p><code>'\\/'(B1, B2)</code> evaluates the expressions <var>B1</var> and <var>B2</var> with values <var>VB1</var> and <var>VB2</var> and has the value such that each bit is set iff at least one of the corresponding bits in <var>VB1</var> and <var>VB2</var> is set.</p>

<p>The value shall be implementation defined if <var>VB1</var> or <var>VB2</var> is negative.</p>

<p>Templates and modes for the predicate are as follows:</p>
<pre>
'\\/'(int-exp, int-exp) = integer
</pre>

<p>Note that <code>\/</code> is an infix predefined operator.</p>

<h3>4.1 Example tests</h3>

<p>First of all, let's start an appropriate fixture.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="2">fit.ActionFixture</td>
  </tr>
  <tr>
    <td>start</td>
    <td>alice.tuprolog.EvaluationFixture</td>
  </tr>
</table>

<p>Then, ask the engine to evaluate an expression and verify the result.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="3">alice.tuprolog.PrologActionFixture</td>
  </tr>
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'\\/'(10, 12).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#ffffcf">14<hr><pre>alice.tuprolog.NoSolutionException<br />	at alice.tuprolog.SolveInfo.getVarValue(SolveInfo.java:171)<br />	at alice.tuprolog.EvaluationFixture.value(EvaluationFixture.java:22)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.TypeAdapter.invoke(Unknown Source)<br />	at fit.TypeAdapter.get(Unknown Source)<br />	at fit.Fixture.check(Unknown Source)<br />	at alice.tuprolog.PrologActionFixture.check(PrologActionFixture.java:18)<br />	at sun.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.ActionFixture.doCells(Unknown Source)<br />	at fit.Fixture.doRow(Unknown Source)<br />	at fit.Fixture.doRows(Unknown Source)<br />	at fit.Fixture.doTable(Unknown Source)<br />	at fit.Fixture.interpretFollowingTables(Unknown Source)<br />	at fit.Fixture.interpretTables(Unknown Source)<br />	at fit.Fixture.doTables(Unknown Source)<br />	at fit.FileRunner.process(Unknown Source)<br />	at fit.FileRunner.run(Unknown Source)<br />	at fit.FileRunner.main(Unknown Source)<br /></pre></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>\/(10, 12).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#ffffcf">14<hr><pre>alice.tuprolog.MalformedGoalException<br />	at alice.tuprolog.Prolog.solve(Prolog.java:407)<br />	at alice.tuprolog.EvaluationFixture.value(EvaluationFixture.java:21)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.TypeAdapter.invoke(Unknown Source)<br />	at fit.TypeAdapter.get(Unknown Source)<br />	at fit.Fixture.check(Unknown Source)<br />	at alice.tuprolog.PrologActionFixture.check(PrologActionFixture.java:18)<br />	at sun.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.ActionFixture.doCells(Unknown Source)<br />	at fit.Fixture.doRow(Unknown Source)<br />	at fit.Fixture.doRows(Unknown Source)<br />	at fit.Fixture.doTable(Unknown Source)<br />	at fit.Fixture.interpretFollowingTables(Unknown Source)<br />	at fit.Fixture.interpretTables(Unknown Source)<br />	at fit.Fixture.doTables(Unknown Source)<br />	at fit.FileRunner.process(Unknown Source)<br />	at fit.FileRunner.run(Unknown Source)<br />	at fit.FileRunner.main(Unknown Source)<br /></pre></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'\\/'(125, 255).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#ffffcf">255<hr><pre>alice.tuprolog.NoSolutionException<br />	at alice.tuprolog.SolveInfo.getVarValue(SolveInfo.java:171)<br />	at alice.tuprolog.EvaluationFixture.value(EvaluationFixture.java:22)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.TypeAdapter.invoke(Unknown Source)<br />	at fit.TypeAdapter.get(Unknown Source)<br />	at fit.Fixture.check(Unknown Source)<br />	at alice.tuprolog.PrologActionFixture.check(PrologActionFixture.java:18)<br />	at sun.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.ActionFixture.doCells(Unknown Source)<br />	at fit.Fixture.doRow(Unknown Source)<br />	at fit.Fixture.doRows(Unknown Source)<br />	at fit.Fixture.doTable(Unknown Source)<br />	at fit.Fixture.interpretFollowingTables(Unknown Source)<br />	at fit.Fixture.interpretTables(Unknown Source)<br />	at fit.Fixture.doTables(Unknown Source)<br />	at fit.FileRunner.process(Unknown Source)<br />	at fit.FileRunner.run(Unknown Source)<br />	at fit.FileRunner.main(Unknown Source)<br /></pre></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>\/(-10, 12).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td> <font color="#808080">error</font></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'\\/'(77, N).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">instantiation_error</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'\\/'(foo, 2).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">type_error(integer, foo)</td>
  </tr>
</table>

<h2>5. <code>(\)/1</code> (bitwise complement)</h2>

<p><code>'\\'(B1)</code> evaluates the expression <var>B1</var> with value <var>VB1</var> and has the value such that each bit is set iff the corresponding bit in <var>VB1</var> is not set.</p>

<p>The value shall be implementation defined.</p>

<p>Templates and modes for the predicate are as follows:</p>
<pre>
'\\'(int-exp, int-exp) = integer
</pre>

<p>Note that <code>\</code> is an prefix predefined operator.</p>

<h3>5.1 Example tests</h3>

<p>First of all, let's start an appropriate fixture.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="2">fit.ActionFixture</td>
  </tr>
  <tr>
    <td>start</td>
    <td>alice.tuprolog.EvaluationFixture</td>
  </tr>
</table>

<p>Then, ask the engine to evaluate an expression and verify the result.</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <td colspan="3">alice.tuprolog.PrologActionFixture</td>
  </tr>
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'\\'('\\'(10)).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#ffffcf">10<hr><pre>alice.tuprolog.NoSolutionException<br />	at alice.tuprolog.SolveInfo.getVarValue(SolveInfo.java:171)<br />	at alice.tuprolog.EvaluationFixture.value(EvaluationFixture.java:22)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.TypeAdapter.invoke(Unknown Source)<br />	at fit.TypeAdapter.get(Unknown Source)<br />	at fit.Fixture.check(Unknown Source)<br />	at alice.tuprolog.PrologActionFixture.check(PrologActionFixture.java:18)<br />	at sun.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)<br />	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br />	at java.lang.reflect.Method.invoke(Unknown Source)<br />	at fit.ActionFixture.doCells(Unknown Source)<br />	at fit.Fixture.doRow(Unknown Source)<br />	at fit.Fixture.doRows(Unknown Source)<br />	at fit.Fixture.doTable(Unknown Source)<br />	at fit.Fixture.interpretFollowingTables(Unknown Source)<br />	at fit.Fixture.interpretTables(Unknown Source)<br />	at fit.Fixture.doTables(Unknown Source)<br />	at fit.FileRunner.process(Unknown Source)<br />	at fit.FileRunner.run(Unknown Source)<br />	at fit.FileRunner.main(Unknown Source)<br /></pre></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>\(\(10)).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td bgcolor="#cfffcf">10</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>\(10).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>value</td>
    <td> <font color="#808080">-11</font></td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'\\'(N).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">instantiation_error</td>
  </tr>
  
  <tr>
    <td>enter</td>
    <td>evaluable</td>
    <td>'\\'(2.5).</td>
  </tr>
  <tr>
    <td>check</td>
    <td>exception</td>
    <td bgcolor="#efefef">type_error(integer, 2.5)</td>
  </tr>
</table>

<p><a href="../cgi-bin/fit.cgi">Run</a> the tests!</p>

<hr>

<p>The results of the tests for <em>Bitwise functors</em> are as follows:</p>

<table border="1" cellspacing="0" cellpadding="3">
  <tr><td>fit.Summary</td></tr>
<tr>
<td> <font color="#808080">counts</font></td>
<td bgcolor="#ffcfcf">5 right, 0 wrong, 10 ignored, 7 exceptions</td></tr>
<tr>
<td> <font color="#808080">input file</font></td>
<td> <font color="#808080">D:\Silvia\Merge_Tesi\Tesi\test\bitwiseFunctors.html</font></td></tr>
<tr>
<td> <font color="#808080">input update</font></td>
<td> <font color="#808080">Tue Dec 23 03:02:00 CET 2008</font></td></tr>
<tr>
<td> <font color="#808080">output file</font></td>
<td> <font color="#808080">D:\Silvia\Merge_Tesi\Tesi\test\report_Montanari\bitwiseFunctors.html</font></td></tr>
<tr>
<td> <font color="#808080">run date</font></td>
<td> <font color="#808080">Wed Sep 28 12:47:39 CEST 2011</font></td></tr>
<tr>
<td> <font color="#808080">run elapsed time</font></td>
<td> <font color="#808080">0:00.73</font></td></tr></table>

</body>
</html>